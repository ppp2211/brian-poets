/home/pp3114/.local/lib/python3.5/site-packages/brian2/core/variables.py:174: FutureWarning: Conversion of the second argument of issubdtype from `float` to `np.floating` is deprecated. In future, it will be treated as `np.float64 == np.dtype(float).type`.
  return np.issubdtype(np.bool, self.dtype)
DIAGNOSTIC Created object of class Clock with name defaultclock [brian2.core.names]
WARNING    /home/pp3114/.local/lib/python3.5/site-packages/brian2/core/variables.py:174: FutureWarning: Conversion of the second argument of issubdtype from `float` to `np.floating` is deprecated. In future, it will be treated as `np.float64 == np.dtype(float).type`.
  return np.issubdtype(np.bool, self.dtype)
 [py.warnings]
DIAGNOSTIC Created clock defaultclock with dt=0.0001 [brian2.core.clocks]
DIAGNOSTIC Created object of class NeuronGroup with name neurongroup [brian2.core.names]
DIAGNOSTIC Created BrianObject with name neurongroup, clock=Clock(dt=100. * usecond, name='defaultclock'), when=start, order=0 [brian2.core.base]
DIAGNOSTIC Creating NeuronGroup of size 2, equations dv/dt = (I-v)/tau : 1
I : 1
tau : second. [brian2.groups.neurongroup]
WARNING    /home/pp3114/.local/lib/python3.5/site-packages/brian2/core/variables.py:174: FutureWarning: Conversion of the second argument of issubdtype from `bool` to `np.generic` is deprecated. In future, it will be treated as `np.bool_ == np.dtype(bool).type`.
  return np.issubdtype(np.bool, self.dtype)
 [py.warnings]
DIAGNOSTIC Created object of class Thresholder with name neurongroup_thresholder [brian2.core.names]
DIAGNOSTIC Created BrianObject with name neurongroup_thresholder, clock=Clock(dt=100. * usecond, name='defaultclock'), when=thresholds, order=0 [brian2.core.base]
DIAGNOSTIC Created object of class Resetter with name neurongroup_resetter [brian2.core.names]
DIAGNOSTIC Created BrianObject with name neurongroup_resetter, clock=Clock(dt=100. * usecond, name='defaultclock'), when=resets, order=0 [brian2.core.base]
DIAGNOSTIC Created object of class StateUpdater with name neurongroup_stateupdater [brian2.core.names]
DIAGNOSTIC Created BrianObject with name neurongroup_stateupdater, clock=Clock(dt=100. * usecond, name='defaultclock'), when=groups, order=0 [brian2.core.base]
DIAGNOSTIC Created object of class Synapses with name synapses [brian2.core.names]
DIAGNOSTIC Created BrianObject with name synapses, clock=Clock(dt=100. * usecond, name='defaultclock'), when=start, order=0 [brian2.core.base]
DIAGNOSTIC Created object of class SynapticPathway with name synapses_pre [brian2.core.names]
DIAGNOSTIC Created BrianObject with name synapses_pre, clock=Clock(dt=100. * usecond, name='defaultclock'), when=synapses, order=-1 [brian2.core.base]
WARNING    /home/pp3114/.local/lib/python3.5/site-packages/brian2/synapses/synapses.py:1288: FutureWarning: Conversion of the second argument of issubdtype from `int` to `np.signedinteger` is deprecated. In future, it will be treated as `np.int64 == np.dtype(int).type`.
  if not np.issubdtype(i.dtype, np.int):
 [py.warnings]
WARNING    /home/pp3114/.local/lib/python3.5/site-packages/brian2/synapses/synapses.py:1296: FutureWarning: Conversion of the second argument of issubdtype from `int` to `np.signedinteger` is deprecated. In future, it will be treated as `np.int64 == np.dtype(int).type`.
  if not np.issubdtype(j.dtype, np.int):
 [py.warnings]
DEBUG      Creating synapses from group 'neurongroup' to group 'neurongroup', using pre-defined arrays) [brian2.synapses.synapses]
DIAGNOSTIC Creating code object (group=synapses, template name=synapses_create_array) for abstract code:
    _real_sources = sources
    _real_targets = targets [brian2.codegen.codeobject]
DIAGNOSTIC synapses_synapses_create_array_codeobject abstract code:
    _real_sources = sources
    _real_targets = targets [brian2.devices.device]
DIAGNOSTIC synapses_synapses_create_array_codeobject snippet (scalar):
     [brian2.devices.device]
DIAGNOSTIC synapses_synapses_create_array_codeobject snippet (vector):
    const int32_t targets = _ptr_array_synapses_targets[_idx];
    const int32_t sources = _ptr_array_synapses_sources[_idx];
    const int32_t _real_sources = sources;
    const int32_t _real_targets = targets; [brian2.devices.device]
DIAGNOSTIC synapses_synapses_create_array_codeobject code:
    h_file:
        #ifndef _INCLUDED_synapses_synapses_create_array_codeobject
        #define _INCLUDED_synapses_synapses_create_array_codeobject
        #include "objects.h"
        void _run_synapses_synapses_create_array_codeobject();
        #endif
    cpp_file:
        #include "code_objects/synapses_synapses_create_array_codeobject.h"
        #include "brianlib/common_math.h"
        #include "brianlib/stdint_compat.h"
        #include<cmath>
        #include<ctime>
        #include<iostream>
        #include<fstream>
        ////// SUPPORT CODE ///////
        namespace {
         inline int _brian_mod(int ux, int uy)
         {
             const int x = (int)ux;
             const int y = (int)uy;
             return ((x%y)+y)%y;
         }
         inline long _brian_mod(int ux, long uy)
         {
             const long x = (long)ux;
             const long y = (long)uy;
             return ((x%y)+y)%y;
         }
         inline long long _brian_mod(int ux, long long uy)
         {
             const long long x = (long long)ux;
             const long long y = (long long)uy;
             return ((x%y)+y)%y;
         }
         inline float _brian_mod(int ux, float uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(int ux, double uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(int ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long _brian_mod(long ux, int uy)
         {
             const long x = (long)ux;
             const long y = (long)uy;
             return ((x%y)+y)%y;
         }
         inline long _brian_mod(long ux, long uy)
         {
             const long x = (long)ux;
             const long y = (long)uy;
             return ((x%y)+y)%y;
         }
         inline long long _brian_mod(long ux, long long uy)
         {
             const long long x = (long long)ux;
             const long long y = (long long)uy;
             return ((x%y)+y)%y;
         }
         inline float _brian_mod(long ux, float uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(long ux, double uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long long _brian_mod(long long ux, int uy)
         {
             const long long x = (long long)ux;
             const long long y = (long long)uy;
             return ((x%y)+y)%y;
         }
         inline long long _brian_mod(long long ux, long uy)
         {
             const long long x = (long long)ux;
             const long long y = (long long)uy;
             return ((x%y)+y)%y;
         }
         inline long long _brian_mod(long long ux, long long uy)
         {
             const long long x = (long long)ux;
             const long long y = (long long)uy;
             return ((x%y)+y)%y;
         }
         inline float _brian_mod(long long ux, float uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(long long ux, double uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long long ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline float _brian_mod(float ux, int uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline float _brian_mod(float ux, long uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline float _brian_mod(float ux, long long uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline float _brian_mod(float ux, float uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(float ux, double uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(float ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(double ux, int uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(double ux, long uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(double ux, long long uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(double ux, float uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(double ux, double uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(double ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, int uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, long uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, long long uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, float uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         #ifdef _MSC_VER
         #define _brian_pow(x, y) (pow((double)(x), (y)))
         #else
         #define _brian_pow(x, y) (pow((x), (y)))
         #endif
        }
        ////// HASH DEFINES ///////
        void _run_synapses_synapses_create_array_codeobject()
        {
        	using namespace brian;
            const std::clock_t _start_time = std::clock();
        	///// CONSTANTS ///////////
        	%CONSTANTS%
        	///// POINTERS ////////////
         int32_t* __restrict  _ptr_array_synapses__synaptic_post = _array_synapses__synaptic_post;
         int32_t* __restrict  _ptr_array_synapses_targets = _array_synapses_targets;
         int32_t* __restrict  _ptr_array_synapses__synaptic_pre = _array_synapses__synaptic_pre;
         int32_t* __restrict  _ptr_array_synapses_N_outgoing = _array_synapses_N_outgoing;
         int32_t* __restrict  _ptr_array_synapses_N_incoming = _array_synapses_N_incoming;
         int32_t* __restrict  _ptr_array_synapses_sources = _array_synapses_sources;
         int32_t*   _ptr_array_synapses_N = _array_synapses_N;
        const int _old_num_synapses = _ptr_array_synapses_N[0];
        const int _new_num_synapses = _old_num_synapses + _numsources;
        const int _N_pre = N_pre;
        const int _N_post = N_post;
        _dynamic_array_synapses_N_incoming.resize(_N_post + _target_offset);
        _dynamic_array_synapses_N_outgoing.resize(_N_pre + _source_offset);
        for (int _idx=0; _idx<_numsources; _idx++) {
            const int32_t targets = _ptr_array_synapses_targets[_idx];
            const int32_t sources = _ptr_array_synapses_sources[_idx];
            const int32_t _real_sources = sources;
            const int32_t _real_targets = targets;
            _dynamic_array_synapses__synaptic_pre.push_back(_real_sources);
            _dynamic_array_synapses__synaptic_post.push_back(_real_targets);
            // Update the number of total outgoing/incoming synapses per source/target neuron
            _dynamic_array_synapses_N_outgoing[_real_sources]++;
            _dynamic_array_synapses_N_incoming[_real_targets]++;
        }
        // now we need to resize all registered variables
        const int newsize = _dynamic_array_synapses__synaptic_pre.size();
        _dynamic_array_synapses__synaptic_post.resize(newsize);
        _dynamic_array_synapses__synaptic_pre.resize(newsize);
        _dynamic_array_synapses_delay.resize(newsize);
        _dynamic_array_synapses_lastupdate.resize(newsize);
        // Also update the total number of synapses
        _ptr_array_synapses_N[0] = newsize;
            const double _run_time = (double)(std::clock() -_start_time)/CLOCKS_PER_SEC;
            synapses_synapses_create_array_codeobject_profiling_info += _run_time;
        } [brian2.devices.device]
DIAGNOSTIC Created object of class CPPStandaloneCodeObject with name synapses_synapses_create_array_codeobject [brian2.core.names]
DIAGNOSTIC Created object of class StateMonitor with name statemonitor [brian2.core.names]
DIAGNOSTIC Created BrianObject with name statemonitor, clock=Clock(dt=100. * usecond, name='defaultclock'), when=start, order=0 [brian2.core.base]
DEBUG      Updated MagicNetwork to include 7 objects with names neurongroup, statemonitor, synapses, neurongroup_stateupdater, neurongroup_resetter, neurongroup_thresholder, synapses_pre [brian2.core.magic.magic_objects]
DIAGNOSTIC Setting Clock defaultclock to t=<defaultclock.t: 0. * second>, dt=0.0001 [brian2.core.clocks]
DEBUG      Preparing network magicnetwork with 7 objects: neurongroup, statemonitor, synapses, neurongroup_stateupdater, neurongroup_thresholder, synapses_pre, neurongroup_resetter [brian2.core.network.before_run]
DIAGNOSTIC Creating code object (group=statemonitor, template name=statemonitor) for abstract code:
    _to_record_v = _source_v [brian2.codegen.codeobject]
DIAGNOSTIC statemonitor_codeobject abstract code:
    _to_record_v = _source_v [brian2.devices.device]
DIAGNOSTIC statemonitor_codeobject snippet (scalar):
     [brian2.devices.device]
DIAGNOSTIC statemonitor_codeobject snippet (vector):
    const double _source_v = _ptr_array_neurongroup_v[_idx];
    const double _to_record_v = _source_v; [brian2.devices.device]
DIAGNOSTIC statemonitor_codeobject code:
    h_file:
        #ifndef _INCLUDED_statemonitor_codeobject
        #define _INCLUDED_statemonitor_codeobject
        #include "objects.h"
        void _run_statemonitor_codeobject();
        #endif
    cpp_file:
        #include "code_objects/statemonitor_codeobject.h"
        #include "brianlib/common_math.h"
        #include "brianlib/stdint_compat.h"
        #include<cmath>
        #include<ctime>
        #include<iostream>
        #include<fstream>
        ////// SUPPORT CODE ///////
        namespace {
         inline int _brian_mod(int ux, int uy)
         {
             const int x = (int)ux;
             const int y = (int)uy;
             return ((x%y)+y)%y;
         }
         inline long _brian_mod(int ux, long uy)
         {
             const long x = (long)ux;
             const long y = (long)uy;
             return ((x%y)+y)%y;
         }
         inline long long _brian_mod(int ux, long long uy)
         {
             const long long x = (long long)ux;
             const long long y = (long long)uy;
             return ((x%y)+y)%y;
         }
         inline float _brian_mod(int ux, float uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(int ux, double uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(int ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long _brian_mod(long ux, int uy)
         {
             const long x = (long)ux;
             const long y = (long)uy;
             return ((x%y)+y)%y;
         }
         inline long _brian_mod(long ux, long uy)
         {
             const long x = (long)ux;
             const long y = (long)uy;
             return ((x%y)+y)%y;
         }
         inline long long _brian_mod(long ux, long long uy)
         {
             const long long x = (long long)ux;
             const long long y = (long long)uy;
             return ((x%y)+y)%y;
         }
         inline float _brian_mod(long ux, float uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(long ux, double uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long long _brian_mod(long long ux, int uy)
         {
             const long long x = (long long)ux;
             const long long y = (long long)uy;
             return ((x%y)+y)%y;
         }
         inline long long _brian_mod(long long ux, long uy)
         {
             const long long x = (long long)ux;
             const long long y = (long long)uy;
             return ((x%y)+y)%y;
         }
         inline long long _brian_mod(long long ux, long long uy)
         {
             const long long x = (long long)ux;
             const long long y = (long long)uy;
             return ((x%y)+y)%y;
         }
         inline float _brian_mod(long long ux, float uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(long long ux, double uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long long ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline float _brian_mod(float ux, int uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline float _brian_mod(float ux, long uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline float _brian_mod(float ux, long long uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline float _brian_mod(float ux, float uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(float ux, double uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(float ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(double ux, int uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(double ux, long uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(double ux, long long uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(double ux, float uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(double ux, double uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(double ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, int uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, long uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, long long uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, float uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         #ifdef _MSC_VER
         #define _brian_pow(x, y) (pow((double)(x), (y)))
         #else
         #define _brian_pow(x, y) (pow((x), (y)))
         #endif
        }
        ////// HASH DEFINES ///////
        void _run_statemonitor_codeobject()
        {
        	using namespace brian;
            const std::clock_t _start_time = std::clock();
        	///// CONSTANTS ///////////
        	%CONSTANTS%
        	///// POINTERS ////////////
         int32_t* __restrict  _ptr_array_statemonitor__indices = _array_statemonitor__indices;
         double*   _ptr_array_defaultclock_t = _array_defaultclock_t;
         double* __restrict  _ptr_array_statemonitor_t = _array_statemonitor_t;
         double* __restrict  _ptr_array_neurongroup_v = _array_neurongroup_v;
         int32_t*   _ptr_array_statemonitor_N = _array_statemonitor_N;
            _dynamic_array_statemonitor_t.push_back(_ptr_array_defaultclock_t[0]);
            const int _new_size = _dynamic_array_statemonitor_t.size();
            // Resize the dynamic arrays
            _dynamic_array_statemonitor_v.resize(_new_size, _num_indices);
            // scalar code
            const int _vectorisation_idx = -1;
            for (int _i = 0; _i < _num_indices; _i++)
            {
                // vector code
                const int _idx = _ptr_array_statemonitor__indices[_i];
                const int _vectorisation_idx = _idx;
                            const double _source_v = _ptr_array_neurongroup_v[_idx];
                            const double _to_record_v = _source_v;
                    _dynamic_array_statemonitor_v(_new_size-1, _i) = _to_record_v;
            }
            _ptr_array_statemonitor_N[0] = _new_size;
            const double _run_time = (double)(std::clock() -_start_time)/CLOCKS_PER_SEC;
            statemonitor_codeobject_profiling_info += _run_time;
        } [brian2.devices.device]
DIAGNOSTIC Created object of class CPPStandaloneCodeObject with name statemonitor_codeobject [brian2.core.names]
DEBUG      Group neurongroup: using numerical integration method exact (took 0.04s) [brian2.stateupdaters.base.method_choice]
DIAGNOSTIC Creating code object (group=neurongroup, template name=stateupdate) for abstract code:
    _v = I - I*exp(-dt/tau) + v*exp(-dt/tau)
    v = _v [brian2.codegen.codeobject]
DIAGNOSTIC neurongroup_stateupdater_codeobject abstract code:
    _v = I - I*exp(-dt/tau) + v*exp(-dt/tau)
    v = _v [brian2.devices.device]
DIAGNOSTIC neurongroup_stateupdater_codeobject snippet (scalar):
    const double dt = _ptr_array_defaultclock_dt[0];
    const double _lio_1 = - dt; [brian2.devices.device]
DIAGNOSTIC neurongroup_stateupdater_codeobject snippet (vector):
    const double I = _ptr_array_neurongroup_I[_idx];
    double v = _ptr_array_neurongroup_v[_idx];
    const double tau = _ptr_array_neurongroup_tau[_idx];
    const double _v = (I + (v * exp(_lio_1 / tau))) - (I * exp(_lio_1 / tau));
    v = _v;
    _ptr_array_neurongroup_v[_idx] = v; [brian2.devices.device]
DIAGNOSTIC neurongroup_stateupdater_codeobject code:
    h_file:
        #ifndef _INCLUDED_neurongroup_stateupdater_codeobject
        #define _INCLUDED_neurongroup_stateupdater_codeobject
        #include "objects.h"
        void _run_neurongroup_stateupdater_codeobject();
        #endif
    cpp_file:
        #include "code_objects/neurongroup_stateupdater_codeobject.h"
        #include "brianlib/common_math.h"
        #include "brianlib/stdint_compat.h"
        #include<cmath>
        #include<ctime>
        #include<iostream>
        #include<fstream>
        ////// SUPPORT CODE ///////
        namespace {
         inline int _brian_mod(int ux, int uy)
         {
             const int x = (int)ux;
             const int y = (int)uy;
             return ((x%y)+y)%y;
         }
         inline long _brian_mod(int ux, long uy)
         {
             const long x = (long)ux;
             const long y = (long)uy;
             return ((x%y)+y)%y;
         }
         inline long long _brian_mod(int ux, long long uy)
         {
             const long long x = (long long)ux;
             const long long y = (long long)uy;
             return ((x%y)+y)%y;
         }
         inline float _brian_mod(int ux, float uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(int ux, double uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(int ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long _brian_mod(long ux, int uy)
         {
             const long x = (long)ux;
             const long y = (long)uy;
             return ((x%y)+y)%y;
         }
         inline long _brian_mod(long ux, long uy)
         {
             const long x = (long)ux;
             const long y = (long)uy;
             return ((x%y)+y)%y;
         }
         inline long long _brian_mod(long ux, long long uy)
         {
             const long long x = (long long)ux;
             const long long y = (long long)uy;
             return ((x%y)+y)%y;
         }
         inline float _brian_mod(long ux, float uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(long ux, double uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long long _brian_mod(long long ux, int uy)
         {
             const long long x = (long long)ux;
             const long long y = (long long)uy;
             return ((x%y)+y)%y;
         }
         inline long long _brian_mod(long long ux, long uy)
         {
             const long long x = (long long)ux;
             const long long y = (long long)uy;
             return ((x%y)+y)%y;
         }
         inline long long _brian_mod(long long ux, long long uy)
         {
             const long long x = (long long)ux;
             const long long y = (long long)uy;
             return ((x%y)+y)%y;
         }
         inline float _brian_mod(long long ux, float uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(long long ux, double uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long long ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline float _brian_mod(float ux, int uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline float _brian_mod(float ux, long uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline float _brian_mod(float ux, long long uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline float _brian_mod(float ux, float uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(float ux, double uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(float ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(double ux, int uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(double ux, long uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(double ux, long long uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(double ux, float uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(double ux, double uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(double ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, int uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, long uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, long long uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, float uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         #ifdef _MSC_VER
         #define _brian_pow(x, y) (pow((double)(x), (y)))
         #else
         #define _brian_pow(x, y) (pow((x), (y)))
         #endif
        }
        ////// HASH DEFINES ///////
        void _run_neurongroup_stateupdater_codeobject()
        {
        	using namespace brian;
            const std::clock_t _start_time = std::clock();
        	///// CONSTANTS ///////////
        	%CONSTANTS%
        	///// POINTERS ////////////
         double* __restrict  _ptr_array_neurongroup_I = _array_neurongroup_I;
         double*   _ptr_array_defaultclock_dt = _array_defaultclock_dt;
         double* __restrict  _ptr_array_neurongroup_v = _array_neurongroup_v;
         double* __restrict  _ptr_array_neurongroup_tau = _array_neurongroup_tau;
        	//// MAIN CODE ////////////
        	// scalar code
        	const int _vectorisation_idx = -1;
         const double dt = _ptr_array_defaultclock_dt[0];
         const double _lio_1 = - dt;
        	const int _N = N;
        	for(int _idx=0; _idx<_N; _idx++)
        	{
        	    // vector code
        		const int _vectorisation_idx = _idx;
                const double I = _ptr_array_neurongroup_I[_idx];
                double v = _ptr_array_neurongroup_v[_idx];
                const double tau = _ptr_array_neurongroup_tau[_idx];
                const double _v = (I + (v * exp(_lio_1 / tau))) - (I * exp(_lio_1 / tau));
                v = _v;
                _ptr_array_neurongroup_v[_idx] = v;
        	}
            const double _run_time = (double)(std::clock() -_start_time)/CLOCKS_PER_SEC;
            neurongroup_stateupdater_codeobject_profiling_info += _run_time;
        } [brian2.devices.device]
DIAGNOSTIC Created object of class CPPStandaloneCodeObject with name neurongroup_stateupdater_codeobject [brian2.core.names]
DIAGNOSTIC Creating code object (group=neurongroup, template name=threshold) for abstract code:
    _cond = v>1 [brian2.codegen.codeobject]
DIAGNOSTIC neurongroup_thresholder_codeobject abstract code:
    _cond = v>1 [brian2.devices.device]
DIAGNOSTIC neurongroup_thresholder_codeobject snippet (scalar):
     [brian2.devices.device]
DIAGNOSTIC neurongroup_thresholder_codeobject snippet (vector):
    const double v = _ptr_array_neurongroup_v[_idx];
    const char _cond = v > 1; [brian2.devices.device]
DIAGNOSTIC neurongroup_thresholder_codeobject code:
    h_file:
        #ifndef _INCLUDED_neurongroup_thresholder_codeobject
        #define _INCLUDED_neurongroup_thresholder_codeobject
        #include "objects.h"
        void _run_neurongroup_thresholder_codeobject();
        #endif
    cpp_file:
        #include "code_objects/neurongroup_thresholder_codeobject.h"
        #include "brianlib/common_math.h"
        #include "brianlib/stdint_compat.h"
        #include<cmath>
        #include<ctime>
        #include<iostream>
        #include<fstream>
        ////// SUPPORT CODE ///////
        namespace {
         inline int _brian_mod(int ux, int uy)
         {
             const int x = (int)ux;
             const int y = (int)uy;
             return ((x%y)+y)%y;
         }
         inline long _brian_mod(int ux, long uy)
         {
             const long x = (long)ux;
             const long y = (long)uy;
             return ((x%y)+y)%y;
         }
         inline long long _brian_mod(int ux, long long uy)
         {
             const long long x = (long long)ux;
             const long long y = (long long)uy;
             return ((x%y)+y)%y;
         }
         inline float _brian_mod(int ux, float uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(int ux, double uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(int ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long _brian_mod(long ux, int uy)
         {
             const long x = (long)ux;
             const long y = (long)uy;
             return ((x%y)+y)%y;
         }
         inline long _brian_mod(long ux, long uy)
         {
             const long x = (long)ux;
             const long y = (long)uy;
             return ((x%y)+y)%y;
         }
         inline long long _brian_mod(long ux, long long uy)
         {
             const long long x = (long long)ux;
             const long long y = (long long)uy;
             return ((x%y)+y)%y;
         }
         inline float _brian_mod(long ux, float uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(long ux, double uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long long _brian_mod(long long ux, int uy)
         {
             const long long x = (long long)ux;
             const long long y = (long long)uy;
             return ((x%y)+y)%y;
         }
         inline long long _brian_mod(long long ux, long uy)
         {
             const long long x = (long long)ux;
             const long long y = (long long)uy;
             return ((x%y)+y)%y;
         }
         inline long long _brian_mod(long long ux, long long uy)
         {
             const long long x = (long long)ux;
             const long long y = (long long)uy;
             return ((x%y)+y)%y;
         }
         inline float _brian_mod(long long ux, float uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(long long ux, double uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long long ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline float _brian_mod(float ux, int uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline float _brian_mod(float ux, long uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline float _brian_mod(float ux, long long uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline float _brian_mod(float ux, float uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(float ux, double uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(float ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(double ux, int uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(double ux, long uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(double ux, long long uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(double ux, float uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(double ux, double uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(double ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, int uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, long uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, long long uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, float uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         #ifdef _MSC_VER
         #define _brian_pow(x, y) (pow((double)(x), (y)))
         #else
         #define _brian_pow(x, y) (pow((x), (y)))
         #endif
        }
        ////// HASH DEFINES ///////
        void _run_neurongroup_thresholder_codeobject()
        {
        	using namespace brian;
            const std::clock_t _start_time = std::clock();
        	///// CONSTANTS ///////////
        	%CONSTANTS%
        	///// POINTERS ////////////
         double* __restrict  _ptr_array_neurongroup_v = _array_neurongroup_v;
         int32_t* __restrict  _ptr_array_neurongroup__spikespace = _array_neurongroup__spikespace;
        	//// MAIN CODE ////////////
        	// scalar code
        	const int _vectorisation_idx = -1;
            long _count = 0;
            for(int _idx=0; _idx<N; _idx++)
            {
                const int _vectorisation_idx = _idx;
                const double v = _ptr_array_neurongroup_v[_idx];
                const char _cond = v > 1;
                if(_cond) {
                    _ptr_array_neurongroup__spikespace[_count++] = _idx;
                }
            }
            _ptr_array_neurongroup__spikespace[N] = _count;
            const double _run_time = (double)(std::clock() -_start_time)/CLOCKS_PER_SEC;
            neurongroup_thresholder_codeobject_profiling_info += _run_time;
        } [brian2.devices.device]
DIAGNOSTIC Created object of class CPPStandaloneCodeObject with name neurongroup_thresholder_codeobject [brian2.core.names]
DIAGNOSTIC Creating code object (group=synapses_pre, template name=synapses_initialise_queue) for abstract code:
     [brian2.codegen.codeobject]
DIAGNOSTIC synapses_pre_initialise_queue abstract code:
     [brian2.devices.device]
DIAGNOSTIC synapses_pre_initialise_queue snippet (scalar):
     [brian2.devices.device]
DIAGNOSTIC synapses_pre_initialise_queue snippet (vector):
     [brian2.devices.device]
DIAGNOSTIC synapses_pre_initialise_queue code:
    h_file:
        #ifndef _INCLUDED_synapses_pre_initialise_queue
        #define _INCLUDED_synapses_pre_initialise_queue
        void _run_synapses_pre_initialise_queue();
        #endif
    cpp_file:
        #include "code_objects/synapses_pre_initialise_queue.h"
        void _run_synapses_pre_initialise_queue() {
        	using namespace brian;
         double*   _ptr_array_defaultclock_dt = _array_defaultclock_dt;
            double* real_delays = synapses_pre.delay.empty() ? 0 : &(synapses_pre.delay[0]);
            int32_t* sources = synapses_pre.sources.empty() ? 0 : &(synapses_pre.sources[0]);
            const unsigned int n_delays = synapses_pre.delay.size();
            const unsigned int n_synapses = synapses_pre.sources.size();
            synapses_pre.prepare(_n_sources,
                                _n_targets,
                                real_delays, n_delays, sources,
                                n_synapses,
                                _ptr_array_defaultclock_dt[0]);
        } [brian2.devices.device]
DIAGNOSTIC Created object of class CPPStandaloneCodeObject with name synapses_pre_initialise_queue [brian2.core.names]
DIAGNOSTIC Creating code object (group=synapses, template name=synapses) for abstract code:
    v_post += 0.2
    lastupdate = t [brian2.codegen.codeobject]
DIAGNOSTIC synapses_pre_codeobject abstract code:
    v_post += 0.2
    lastupdate = t [brian2.devices.device]
DIAGNOSTIC synapses_pre_codeobject snippet (scalar):
     [brian2.devices.device]
DIAGNOSTIC synapses_pre_codeobject snippet (vector):
    const int32_t _postsynaptic_idx = _ptr_array_synapses__synaptic_post[_idx];
    const double t = _ptr_array_defaultclock_t[0];
    double v_post = _ptr_array_neurongroup_v[_postsynaptic_idx];
    double lastupdate;
    v_post += 0.2;
    lastupdate = t;
    _ptr_array_synapses_lastupdate[_idx] = lastupdate;
    _ptr_array_neurongroup_v[_postsynaptic_idx] = v_post; [brian2.devices.device]
DIAGNOSTIC synapses_pre_codeobject code:
    main_finalise:
        #ifdef DEBUG
        _debugmsg_synapses_pre_codeobject();
        #endif
    h_file:
        #ifndef _INCLUDED_synapses_pre_codeobject
        #define _INCLUDED_synapses_pre_codeobject
        #include "objects.h"
        void _run_synapses_pre_codeobject();
        void _debugmsg_synapses_pre_codeobject();
        #endif
    cpp_file:
        #include "code_objects/synapses_pre_codeobject.h"
        #include "brianlib/common_math.h"
        #include "brianlib/stdint_compat.h"
        #include<cmath>
        #include<ctime>
        #include<iostream>
        #include<fstream>
        #include "brianlib/stdint_compat.h"
        #include "synapses_classes.h"
        ////// SUPPORT CODE ///////
        namespace {
         inline int _brian_mod(int ux, int uy)
         {
             const int x = (int)ux;
             const int y = (int)uy;
             return ((x%y)+y)%y;
         }
         inline long _brian_mod(int ux, long uy)
         {
             const long x = (long)ux;
             const long y = (long)uy;
             return ((x%y)+y)%y;
         }
         inline long long _brian_mod(int ux, long long uy)
         {
             const long long x = (long long)ux;
             const long long y = (long long)uy;
             return ((x%y)+y)%y;
         }
         inline float _brian_mod(int ux, float uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(int ux, double uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(int ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long _brian_mod(long ux, int uy)
         {
             const long x = (long)ux;
             const long y = (long)uy;
             return ((x%y)+y)%y;
         }
         inline long _brian_mod(long ux, long uy)
         {
             const long x = (long)ux;
             const long y = (long)uy;
             return ((x%y)+y)%y;
         }
         inline long long _brian_mod(long ux, long long uy)
         {
             const long long x = (long long)ux;
             const long long y = (long long)uy;
             return ((x%y)+y)%y;
         }
         inline float _brian_mod(long ux, float uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(long ux, double uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long long _brian_mod(long long ux, int uy)
         {
             const long long x = (long long)ux;
             const long long y = (long long)uy;
             return ((x%y)+y)%y;
         }
         inline long long _brian_mod(long long ux, long uy)
         {
             const long long x = (long long)ux;
             const long long y = (long long)uy;
             return ((x%y)+y)%y;
         }
         inline long long _brian_mod(long long ux, long long uy)
         {
             const long long x = (long long)ux;
             const long long y = (long long)uy;
             return ((x%y)+y)%y;
         }
         inline float _brian_mod(long long ux, float uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(long long ux, double uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long long ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline float _brian_mod(float ux, int uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline float _brian_mod(float ux, long uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline float _brian_mod(float ux, long long uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline float _brian_mod(float ux, float uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(float ux, double uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(float ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(double ux, int uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(double ux, long uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(double ux, long long uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(double ux, float uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(double ux, double uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(double ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, int uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, long uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, long long uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, float uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         #ifdef _MSC_VER
         #define _brian_pow(x, y) (pow((double)(x), (y)))
         #else
         #define _brian_pow(x, y) (pow((x), (y)))
         #endif
        }
        ////// HASH DEFINES ///////
        void _run_synapses_pre_codeobject()
        {
        	using namespace brian;
            const std::clock_t _start_time = std::clock();
        	///// CONSTANTS ///////////
        	%CONSTANTS%
        	///// POINTERS ////////////
         double* __restrict  _ptr_array_synapses_lastupdate = _array_synapses_lastupdate;
         int32_t* __restrict  _ptr_array_synapses__synaptic_pre = _array_synapses__synaptic_pre;
         int32_t* __restrict  _ptr_array_synapses__synaptic_post = _array_synapses__synaptic_post;
         double*   _ptr_array_defaultclock_t = _array_defaultclock_t;
         double* __restrict  _ptr_array_neurongroup_v = _array_neurongroup_v;
        	// This is only needed for the _debugmsg function below	
        	// scalar code
        	const int _vectorisation_idx = -1;
        	{
        	std::vector<int> *_spiking_synapses = synapses_pre.peek();
        	const unsigned int _num_spiking_synapses = _spiking_synapses->size();
        	{
        		for(unsigned int _spiking_synapse_idx=0;
        			_spiking_synapse_idx<_num_spiking_synapses;
        			_spiking_synapse_idx++)
        		{
        			const int _idx = (*_spiking_synapses)[_spiking_synapse_idx];
        			const int _vectorisation_idx = _idx;
           const int32_t _postsynaptic_idx = _ptr_array_synapses__synaptic_post[_idx];
           const double t = _ptr_array_defaultclock_t[0];
           double v_post = _ptr_array_neurongroup_v[_postsynaptic_idx];
           double lastupdate;
           v_post += 0.2;
           lastupdate = t;
           _ptr_array_synapses_lastupdate[_idx] = lastupdate;
           _ptr_array_neurongroup_v[_postsynaptic_idx] = v_post;
        		}
        	}
            }
            const double _run_time = (double)(std::clock() -_start_time)/CLOCKS_PER_SEC;
            synapses_pre_codeobject_profiling_info += _run_time;
        }
        void _debugmsg_synapses_pre_codeobject()
        {
        	using namespace brian;
        	std::cout << "Number of synapses: " << _dynamic_array_synapses__synaptic_pre.size() << endl;
        } [brian2.devices.device]
DIAGNOSTIC Created object of class CPPStandaloneCodeObject with name synapses_pre_codeobject [brian2.core.names]
DIAGNOSTIC Creating code object (group=synapses_pre, template name=synapses_push_spikes) for abstract code:
     [brian2.codegen.codeobject]
DIAGNOSTIC synapses_pre_push_spikes abstract code:
     [brian2.devices.device]
DIAGNOSTIC synapses_pre_push_spikes snippet (scalar):
     [brian2.devices.device]
DIAGNOSTIC synapses_pre_push_spikes snippet (vector):
     [brian2.devices.device]
DIAGNOSTIC synapses_pre_push_spikes code:
    h_file:
        #ifndef _INCLUDED_synapses_pre_push_spikes
        #define _INCLUDED_synapses_pre_push_spikes
        #include "objects.h"
        void _run_synapses_pre_push_spikes();
        #endif
    cpp_file:
        #include "code_objects/synapses_pre_push_spikes.h"
        #include "brianlib/common_math.h"
        #include "brianlib/stdint_compat.h"
        #include<cmath>
        #include<ctime>
        void _run_synapses_pre_push_spikes()
        {
            using namespace brian;
            const std::clock_t _start_time = std::clock();
            ///// CONSTANTS ///////////
            %CONSTANTS%
            ///// POINTERS ////////////
            int32_t* __restrict  _ptr_array_neurongroup__spikespace = _array_neurongroup__spikespace;
            //// MAIN CODE ////////////
            // we do advance at the beginning rather than at the end because it saves us making
            // a copy of the current spiking synapses
            {
                synapses_pre.advance();
                synapses_pre.push(_ptr_array_neurongroup__spikespace, _ptr_array_neurongroup__spikespace[_num_spikespace-1]);
            }
            // Profiling
            const double _run_time = (double)(std::clock() -_start_time)/CLOCKS_PER_SEC;
            synapses_pre_push_spikes_profiling_info += _run_time;
        } [brian2.devices.device]
DIAGNOSTIC Created object of class CPPStandaloneCodeObject with name synapses_pre_push_spikes [brian2.core.names]
DIAGNOSTIC Creating code object (group=neurongroup, template name=reset) for abstract code:
    v = 0 [brian2.codegen.codeobject]
DIAGNOSTIC neurongroup_resetter_codeobject abstract code:
    v = 0 [brian2.devices.device]
DIAGNOSTIC neurongroup_resetter_codeobject snippet (scalar):
     [brian2.devices.device]
DIAGNOSTIC neurongroup_resetter_codeobject snippet (vector):
    double v;
    v = 0;
    _ptr_array_neurongroup_v[_idx] = v; [brian2.devices.device]
DIAGNOSTIC neurongroup_resetter_codeobject code:
    h_file:
        #ifndef _INCLUDED_neurongroup_resetter_codeobject
        #define _INCLUDED_neurongroup_resetter_codeobject
        #include "objects.h"
        void _run_neurongroup_resetter_codeobject();
        #endif
    cpp_file:
        #include "code_objects/neurongroup_resetter_codeobject.h"
        #include "brianlib/common_math.h"
        #include "brianlib/stdint_compat.h"
        #include<cmath>
        #include<ctime>
        #include<iostream>
        #include<fstream>
        ////// SUPPORT CODE ///////
        namespace {
         inline int _brian_mod(int ux, int uy)
         {
             const int x = (int)ux;
             const int y = (int)uy;
             return ((x%y)+y)%y;
         }
         inline long _brian_mod(int ux, long uy)
         {
             const long x = (long)ux;
             const long y = (long)uy;
             return ((x%y)+y)%y;
         }
         inline long long _brian_mod(int ux, long long uy)
         {
             const long long x = (long long)ux;
             const long long y = (long long)uy;
             return ((x%y)+y)%y;
         }
         inline float _brian_mod(int ux, float uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(int ux, double uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(int ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long _brian_mod(long ux, int uy)
         {
             const long x = (long)ux;
             const long y = (long)uy;
             return ((x%y)+y)%y;
         }
         inline long _brian_mod(long ux, long uy)
         {
             const long x = (long)ux;
             const long y = (long)uy;
             return ((x%y)+y)%y;
         }
         inline long long _brian_mod(long ux, long long uy)
         {
             const long long x = (long long)ux;
             const long long y = (long long)uy;
             return ((x%y)+y)%y;
         }
         inline float _brian_mod(long ux, float uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(long ux, double uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long long _brian_mod(long long ux, int uy)
         {
             const long long x = (long long)ux;
             const long long y = (long long)uy;
             return ((x%y)+y)%y;
         }
         inline long long _brian_mod(long long ux, long uy)
         {
             const long long x = (long long)ux;
             const long long y = (long long)uy;
             return ((x%y)+y)%y;
         }
         inline long long _brian_mod(long long ux, long long uy)
         {
             const long long x = (long long)ux;
             const long long y = (long long)uy;
             return ((x%y)+y)%y;
         }
         inline float _brian_mod(long long ux, float uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(long long ux, double uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long long ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline float _brian_mod(float ux, int uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline float _brian_mod(float ux, long uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline float _brian_mod(float ux, long long uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline float _brian_mod(float ux, float uy)
         {
             const float x = (float)ux;
             const float y = (float)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(float ux, double uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(float ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(double ux, int uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(double ux, long uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(double ux, long long uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(double ux, float uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline double _brian_mod(double ux, double uy)
         {
             const double x = (double)ux;
             const double y = (double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(double ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, int uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, long uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, long long uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, float uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         inline long double _brian_mod(long double ux, long double uy)
         {
             const long double x = (long double)ux;
             const long double y = (long double)uy;
             return fmod(fmod(x, y)+y, y);
         }
         #ifdef _MSC_VER
         #define _brian_pow(x, y) (pow((double)(x), (y)))
         #else
         #define _brian_pow(x, y) (pow((x), (y)))
         #endif
        }
        ////// HASH DEFINES ///////
        void _run_neurongroup_resetter_codeobject()
        {
        	using namespace brian;
            const std::clock_t _start_time = std::clock();
        	///// CONSTANTS ///////////
        	%CONSTANTS%
        	///// POINTERS ////////////
         double* __restrict  _ptr_array_neurongroup_v = _array_neurongroup_v;
         int32_t* __restrict  _ptr_array_neurongroup__spikespace = _array_neurongroup__spikespace;
        	const int32_t *_events = _ptr_array_neurongroup__spikespace;
        	const int32_t _num_events = _ptr_array_neurongroup__spikespace[N];
        	//// MAIN CODE ////////////	
        	// scalar code
        	const int _vectorisation_idx = -1;
        	for(int _index_events=0; _index_events<_num_events; _index_events++)
        	{
        	    // vector code
        		const int _idx = _events[_index_events];
        		const int _vectorisation_idx = _idx;
                double v;
                v = 0;
                _ptr_array_neurongroup_v[_idx] = v;
        	}
            const double _run_time = (double)(std::clock() -_start_time)/CLOCKS_PER_SEC;
            neurongroup_resetter_codeobject_profiling_info += _run_time;
        } [brian2.devices.device]
DIAGNOSTIC Created object of class CPPStandaloneCodeObject with name neurongroup_resetter_codeobject [brian2.core.names]
DEBUG      Network magicnetwork uses 1 clocks: defaultclock (dt=100. us) [brian2.core.network.before_run]
DIAGNOSTIC Writing C++ standalone project to directory output [brian2.devices.cpp_standalone.device]
DIAGNOSTIC static arrays: ['_static_array__array_neurongroup_I', '_static_array__array_neurongroup_tau', '_static_array__array_statemonitor__indices'] [brian2.devices.cpp_standalone.device]
DIAGNOSTIC Creating code object (group=synapses, template name=group_get_indices) for abstract code:
    _cond = name [brian2.codegen.codeobject]
DIAGNOSTIC Creating code object (group=synapses, template name=group_get_indices) for abstract code:
    _cond = name [brian2.codegen.codeobject]
DIAGNOSTIC Writing file objects.*:
h_file:
    #ifndef _BRIAN_OBJECTS_H
    #define _BRIAN_OBJECTS_H
    #include "synapses_classes.h"
    #include "brianlib/clocks.h"
    #include "brianlib/dynamic_array.h"
    #include "brianlib/stdint_compat.h"
    #include "network.h"
    #include "randomkit.h"
    #include<vector>
    namespace brian {
    // In OpenMP we need one state per thread
    extern std::vector< rk_state* > _mersenne_twister_states;
    //////////////// clocks ///////////////////
    extern Clock defaultclock;
    //////////////// networks /////////////////
    extern Network magicnetwork;
    //////////////// dynamic arrays ///////////
    extern std::vector<double> _dynamic_array_statemonitor_t;
    extern std::vector<int32_t> _dynamic_array_synapses__synaptic_post;
    extern std::vector<int32_t> _dynamic_array_synapses__synaptic_pre;
    extern std::vector<double> _dynamic_array_synapses_delay;
    extern std::vector<double> _dynamic_array_synapses_lastupdate;
    extern std::vector<int32_t> _dynamic_array_synapses_N_incoming;
    extern std::vector<int32_t> _dynamic_array_synapses_N_outgoing;
    //////////////// arrays ///////////////////
    extern double *_array_defaultclock_dt;
    extern const int _num__array_defaultclock_dt;
    extern double *_array_defaultclock_t;
    extern const int _num__array_defaultclock_t;
    extern int64_t *_array_defaultclock_timestep;
    extern const int _num__array_defaultclock_timestep;
    extern int32_t *_array_neurongroup__spikespace;
    extern const int _num__array_neurongroup__spikespace;
    extern double *_array_neurongroup_I;
    extern const int _num__array_neurongroup_I;
    extern int32_t *_array_neurongroup_i;
    extern const int _num__array_neurongroup_i;
    extern double *_array_neurongroup_tau;
    extern const int _num__array_neurongroup_tau;
    extern double *_array_neurongroup_v;
    extern const int _num__array_neurongroup_v;
    extern int32_t *_array_statemonitor__indices;
    extern const int _num__array_statemonitor__indices;
    extern int32_t *_array_statemonitor_N;
    extern const int _num__array_statemonitor_N;
    extern double *_array_statemonitor_v;
    extern const int _num__array_statemonitor_v;
    extern int32_t *_array_synapses_N;
    extern const int _num__array_synapses_N;
    extern int32_t *_array_synapses_sources;
    extern const int _num__array_synapses_sources;
    extern int32_t *_array_synapses_targets;
    extern const int _num__array_synapses_targets;
    //////////////// dynamic arrays 2d /////////
    extern DynamicArray2D<double> _dynamic_array_statemonitor_v;
    /////////////// static arrays /////////////
    extern int64_t *_static_array__array_neurongroup_I;
    extern const int _num__static_array__array_neurongroup_I;
    extern double *_static_array__array_neurongroup_tau;
    extern const int _num__static_array__array_neurongroup_tau;
    extern int32_t *_static_array__array_statemonitor__indices;
    extern const int _num__static_array__array_statemonitor__indices;
    //////////////// synapses /////////////////
    // synapses
    extern SynapticPathway<double> synapses_pre;
    // Profiling information for each code object
    extern double neurongroup_resetter_codeobject_profiling_info;
    extern double neurongroup_stateupdater_codeobject_profiling_info;
    extern double neurongroup_thresholder_codeobject_profiling_info;
    extern double statemonitor_codeobject_profiling_info;
    extern double synapses_pre_codeobject_profiling_info;
    extern double synapses_pre_initialise_queue_profiling_info;
    extern double synapses_pre_push_spikes_profiling_info;
    extern double synapses_synapses_create_array_codeobject_profiling_info;
    }
    void _init_arrays();
    void _load_arrays();
    void _write_arrays();
    void _dealloc_arrays();
    #endif
cpp_file:
    #include "objects.h"
    #include "synapses_classes.h"
    #include "brianlib/clocks.h"
    #include "brianlib/dynamic_array.h"
    #include "brianlib/stdint_compat.h"
    #include "network.h"
    #include "randomkit.h"
    #include<vector>
    #include<iostream>
    #include<fstream>
    namespace brian {
    std::vector< rk_state* > _mersenne_twister_states;
    //////////////// networks /////////////////
    Network magicnetwork;
    //////////////// arrays ///////////////////
    double * _array_defaultclock_dt;
    const int _num__array_defaultclock_dt = 1;
    double * _array_defaultclock_t;
    const int _num__array_defaultclock_t = 1;
    int64_t * _array_defaultclock_timestep;
    const int _num__array_defaultclock_timestep = 1;
    int32_t * _array_neurongroup__spikespace;
    const int _num__array_neurongroup__spikespace = 3;
    double * _array_neurongroup_I;
    const int _num__array_neurongroup_I = 2;
    int32_t * _array_neurongroup_i;
    const int _num__array_neurongroup_i = 2;
    double * _array_neurongroup_tau;
    const int _num__array_neurongroup_tau = 2;
    double * _array_neurongroup_v;
    const int _num__array_neurongroup_v = 2;
    int32_t * _array_statemonitor__indices;
    const int _num__array_statemonitor__indices = 2;
    int32_t * _array_statemonitor_N;
    const int _num__array_statemonitor_N = 1;
    double * _array_statemonitor_v;
    const int _num__array_statemonitor_v = (0, 2);
    int32_t * _array_synapses_N;
    const int _num__array_synapses_N = 1;
    int32_t * _array_synapses_sources;
    const int _num__array_synapses_sources = 1;
    int32_t * _array_synapses_targets;
    const int _num__array_synapses_targets = 1;
    //////////////// dynamic arrays 1d /////////
    std::vector<double> _dynamic_array_statemonitor_t;
    std::vector<int32_t> _dynamic_array_synapses__synaptic_post;
    std::vector<int32_t> _dynamic_array_synapses__synaptic_pre;
    std::vector<double> _dynamic_array_synapses_delay;
    std::vector<double> _dynamic_array_synapses_lastupdate;
    std::vector<int32_t> _dynamic_array_synapses_N_incoming;
    std::vector<int32_t> _dynamic_array_synapses_N_outgoing;
    //////////////// dynamic arrays 2d /////////
    DynamicArray2D<double> _dynamic_array_statemonitor_v;
    /////////////// static arrays /////////////
    int64_t * _static_array__array_neurongroup_I;
    const int _num__static_array__array_neurongroup_I = 2;
    double * _static_array__array_neurongroup_tau;
    const int _num__static_array__array_neurongroup_tau = 2;
    int32_t * _static_array__array_statemonitor__indices;
    const int _num__static_array__array_statemonitor__indices = 2;
    //////////////// synapses /////////////////
    // synapses
    SynapticPathway<double> synapses_pre(
    		_dynamic_array_synapses_delay,
    		_dynamic_array_synapses__synaptic_pre,
    		0, 2);
    //////////////// clocks ///////////////////
    Clock defaultclock;  // attributes will be set in run.cpp
    // Profiling information for each code object
    double neurongroup_resetter_codeobject_profiling_info = 0.0;
    double neurongroup_stateupdater_codeobject_profiling_info = 0.0;
    double neurongroup_thresholder_codeobject_profiling_info = 0.0;
    double statemonitor_codeobject_profiling_info = 0.0;
    double synapses_pre_codeobject_profiling_info = 0.0;
    double synapses_pre_initialise_queue_profiling_info = 0.0;
    double synapses_pre_push_spikes_profiling_info = 0.0;
    double synapses_synapses_create_array_codeobject_profiling_info = 0.0;
    }
    void _init_arrays()
    {
    	using namespace brian;
        // Arrays initialized to 0
    	_array_defaultclock_dt = new double[1];
    	for(int i=0; i<1; i++) _array_defaultclock_dt[i] = 0;
    	_array_defaultclock_t = new double[1];
    	for(int i=0; i<1; i++) _array_defaultclock_t[i] = 0;
    	_array_defaultclock_timestep = new int64_t[1];
    	for(int i=0; i<1; i++) _array_defaultclock_timestep[i] = 0;
    	_array_neurongroup__spikespace = new int32_t[3];
    	for(int i=0; i<3; i++) _array_neurongroup__spikespace[i] = 0;
    	_array_neurongroup_i = new int32_t[2];
    	for(int i=0; i<2; i++) _array_neurongroup_i[i] = 0;
    	_array_neurongroup_I = new double[2];
    	for(int i=0; i<2; i++) _array_neurongroup_I[i] = 0;
    	_array_neurongroup_tau = new double[2];
    	for(int i=0; i<2; i++) _array_neurongroup_tau[i] = 0;
    	_array_neurongroup_v = new double[2];
    	for(int i=0; i<2; i++) _array_neurongroup_v[i] = 0;
    	_array_statemonitor__indices = new int32_t[2];
    	for(int i=0; i<2; i++) _array_statemonitor__indices[i] = 0;
    	_array_statemonitor_N = new int32_t[1];
    	for(int i=0; i<1; i++) _array_statemonitor_N[i] = 0;
    	_array_synapses_N = new int32_t[1];
    	for(int i=0; i<1; i++) _array_synapses_N[i] = 0;
    	_array_synapses_sources = new int32_t[1];
    	for(int i=0; i<1; i++) _array_synapses_sources[i] = 0;
    	_array_synapses_targets = new int32_t[1];
    	for(int i=0; i<1; i++) _array_synapses_targets[i] = 0;
    	// Arrays initialized to an "arange"
    	_array_neurongroup_i = new int32_t[2];
    	for(int i=0; i<2; i++) _array_neurongroup_i[i] = 0 + i;
    	// static arrays
    	_static_array__array_neurongroup_I = new int64_t[2];
    	_static_array__array_neurongroup_tau = new double[2];
    	_static_array__array_statemonitor__indices = new int32_t[2];
    	// Random number generator states
    	for (int i=0; i<1; i++)
    	    _mersenne_twister_states.push_back(new rk_state());
    }
    void _load_arrays()
    {
    	using namespace brian;
    	ifstream f_static_array__array_neurongroup_I;
    	f_static_array__array_neurongroup_I.open("static_arrays/_static_array__array_neurongroup_I", ios::in | ios::binary);
    	if(f_static_array__array_neurongroup_I.is_open())
    	{
    		f_static_array__array_neurongroup_I.read(reinterpret_cast<char*>(_static_array__array_neurongroup_I), 2*sizeof(int64_t));
    	} else
    	{
    		std::cout << "Error opening static array _static_array__array_neurongroup_I." << endl;
    	}
    	ifstream f_static_array__array_neurongroup_tau;
    	f_static_array__array_neurongroup_tau.open("static_arrays/_static_array__array_neurongroup_tau", ios::in | ios::binary);
    	if(f_static_array__array_neurongroup_tau.is_open())
    	{
    		f_static_array__array_neurongroup_tau.read(reinterpret_cast<char*>(_static_array__array_neurongroup_tau), 2*sizeof(double));
    	} else
    	{
    		std::cout << "Error opening static array _static_array__array_neurongroup_tau." << endl;
    	}
    	ifstream f_static_array__array_statemonitor__indices;
    	f_static_array__array_statemonitor__indices.open("static_arrays/_static_array__array_statemonitor__indices", ios::in | ios::binary);
    	if(f_static_array__array_statemonitor__indices.is_open())
    	{
    		f_static_array__array_statemonitor__indices.read(reinterpret_cast<char*>(_static_array__array_statemonitor__indices), 2*sizeof(int32_t));
    	} else
    	{
    		std::cout << "Error opening static array _static_array__array_statemonitor__indices." << endl;
    	}
    }
    void _write_arrays()
    {
    	using namespace brian;
    	ofstream outfile__array_defaultclock_dt;
    	outfile__array_defaultclock_dt.open("results/_array_defaultclock_dt_3747468184395835432", ios::binary | ios::out);
    	if(outfile__array_defaultclock_dt.is_open())
    	{
    		outfile__array_defaultclock_dt.write(reinterpret_cast<char*>(_array_defaultclock_dt), 1*sizeof(_array_defaultclock_dt[0]));
    		outfile__array_defaultclock_dt.close();
    	} else
    	{
    		std::cout << "Error writing output file for _array_defaultclock_dt." << endl;
    	}
    	ofstream outfile__array_defaultclock_t;
    	outfile__array_defaultclock_t.open("results/_array_defaultclock_t_-7115825036261727037", ios::binary | ios::out);
    	if(outfile__array_defaultclock_t.is_open())
    	{
    		outfile__array_defaultclock_t.write(reinterpret_cast<char*>(_array_defaultclock_t), 1*sizeof(_array_defaultclock_t[0]));
    		outfile__array_defaultclock_t.close();
    	} else
    	{
    		std::cout << "Error writing output file for _array_defaultclock_t." << endl;
    	}
    	ofstream outfile__array_defaultclock_timestep;
    	outfile__array_defaultclock_timestep.open("results/_array_defaultclock_timestep_2633846103642586746", ios::binary | ios::out);
    	if(outfile__array_defaultclock_timestep.is_open())
    	{
    		outfile__array_defaultclock_timestep.write(reinterpret_cast<char*>(_array_defaultclock_timestep), 1*sizeof(_array_defaultclock_timestep[0]));
    		outfile__array_defaultclock_timestep.close();
    	} else
    	{
    		std::cout << "Error writing output file for _array_defaultclock_timestep." << endl;
    	}
    	ofstream outfile__array_neurongroup__spikespace;
    	outfile__array_neurongroup__spikespace.open("results/_array_neurongroup__spikespace_573674353579096559", ios::binary | ios::out);
    	if(outfile__array_neurongroup__spikespace.is_open())
    	{
    		outfile__array_neurongroup__spikespace.write(reinterpret_cast<char*>(_array_neurongroup__spikespace), 3*sizeof(_array_neurongroup__spikespace[0]));
    		outfile__array_neurongroup__spikespace.close();
    	} else
    	{
    		std::cout << "Error writing output file for _array_neurongroup__spikespace." << endl;
    	}
    	ofstream outfile__array_neurongroup_I;
    	outfile__array_neurongroup_I.open("results/_array_neurongroup_I_-1901320210814771266", ios::binary | ios::out);
    	if(outfile__array_neurongroup_I.is_open())
    	{
    		outfile__array_neurongroup_I.write(reinterpret_cast<char*>(_array_neurongroup_I), 2*sizeof(_array_neurongroup_I[0]));
    		outfile__array_neurongroup_I.close();
    	} else
    	{
    		std::cout << "Error writing output file for _array_neurongroup_I." << endl;
    	}
    	ofstream outfile__array_neurongroup_i;
    	outfile__array_neurongroup_i.open("results/_array_neurongroup_i_-4028626282186028042", ios::binary | ios::out);
    	if(outfile__array_neurongroup_i.is_open())
    	{
    		outfile__array_neurongroup_i.write(reinterpret_cast<char*>(_array_neurongroup_i), 2*sizeof(_array_neurongroup_i[0]));
    		outfile__array_neurongroup_i.close();
    	} else
    	{
    		std::cout << "Error writing output file for _array_neurongroup_i." << endl;
    	}
    	ofstream outfile__array_neurongroup_tau;
    	outfile__array_neurongroup_tau.open("results/_array_neurongroup_tau_-1492113667029771614", ios::binary | ios::out);
    	if(outfile__array_neurongroup_tau.is_open())
    	{
    		outfile__array_neurongroup_tau.write(reinterpret_cast<char*>(_array_neurongroup_tau), 2*sizeof(_array_neurongroup_tau[0]));
    		outfile__array_neurongroup_tau.close();
    	} else
    	{
    		std::cout << "Error writing output file for _array_neurongroup_tau." << endl;
    	}
    	ofstream outfile__array_neurongroup_v;
    	outfile__array_neurongroup_v.open("results/_array_neurongroup_v_-5500494582704731642", ios::binary | ios::out);
    	if(outfile__array_neurongroup_v.is_open())
    	{
    		outfile__array_neurongroup_v.write(reinterpret_cast<char*>(_array_neurongroup_v), 2*sizeof(_array_neurongroup_v[0]));
    		outfile__array_neurongroup_v.close();
    	} else
    	{
    		std::cout << "Error writing output file for _array_neurongroup_v." << endl;
    	}
    	ofstream outfile__array_statemonitor__indices;
    	outfile__array_statemonitor__indices.open("results/_array_statemonitor__indices_-1442741383992362881", ios::binary | ios::out);
    	if(outfile__array_statemonitor__indices.is_open())
    	{
    		outfile__array_statemonitor__indices.write(reinterpret_cast<char*>(_array_statemonitor__indices), 2*sizeof(_array_statemonitor__indices[0]));
    		outfile__array_statemonitor__indices.close();
    	} else
    	{
    		std::cout << "Error writing output file for _array_statemonitor__indices." << endl;
    	}
    	ofstream outfile__array_statemonitor_N;
    	outfile__array_statemonitor_N.open("results/_array_statemonitor_N_3852463596759852795", ios::binary | ios::out);
    	if(outfile__array_statemonitor_N.is_open())
    	{
    		outfile__array_statemonitor_N.write(reinterpret_cast<char*>(_array_statemonitor_N), 1*sizeof(_array_statemonitor_N[0]));
    		outfile__array_statemonitor_N.close();
    	} else
    	{
    		std::cout << "Error writing output file for _array_statemonitor_N." << endl;
    	}
    	ofstream outfile__array_synapses_N;
    	outfile__array_synapses_N.open("results/_array_synapses_N_5284365010639707735", ios::binary | ios::out);
    	if(outfile__array_synapses_N.is_open())
    	{
    		outfile__array_synapses_N.write(reinterpret_cast<char*>(_array_synapses_N), 1*sizeof(_array_synapses_N[0]));
    		outfile__array_synapses_N.close();
    	} else
    	{
    		std::cout << "Error writing output file for _array_synapses_N." << endl;
    	}
    	ofstream outfile__array_synapses_sources;
    	outfile__array_synapses_sources.open("results/_array_synapses_sources_-4112904328018476915", ios::binary | ios::out);
    	if(outfile__array_synapses_sources.is_open())
    	{
    		outfile__array_synapses_sources.write(reinterpret_cast<char*>(_array_synapses_sources), 1*sizeof(_array_synapses_sources[0]));
    		outfile__array_synapses_sources.close();
    	} else
    	{
    		std::cout << "Error writing output file for _array_synapses_sources." << endl;
    	}
    	ofstream outfile__array_synapses_targets;
    	outfile__array_synapses_targets.open("results/_array_synapses_targets_-6890910146927201111", ios::binary | ios::out);
    	if(outfile__array_synapses_targets.is_open())
    	{
    		outfile__array_synapses_targets.write(reinterpret_cast<char*>(_array_synapses_targets), 1*sizeof(_array_synapses_targets[0]));
    		outfile__array_synapses_targets.close();
    	} else
    	{
    		std::cout << "Error writing output file for _array_synapses_targets." << endl;
    	}
    	ofstream outfile__dynamic_array_statemonitor_t;
    	outfile__dynamic_array_statemonitor_t.open("results/_dynamic_array_statemonitor_t_1033670080024100330", ios::binary | ios::out);
    	if(outfile__dynamic_array_statemonitor_t.is_open())
    	{
            if (! _dynamic_array_statemonitor_t.empty() )
            {
    			outfile__dynamic_array_statemonitor_t.write(reinterpret_cast<char*>(&_dynamic_array_statemonitor_t[0]), _dynamic_array_statemonitor_t.size()*sizeof(_dynamic_array_statemonitor_t[0]));
    		    outfile__dynamic_array_statemonitor_t.close();
    		}
    	} else
    	{
    		std::cout << "Error writing output file for _dynamic_array_statemonitor_t." << endl;
    	}
    	ofstream outfile__dynamic_array_synapses__synaptic_post;
    	outfile__dynamic_array_synapses__synaptic_post.open("results/_dynamic_array_synapses__synaptic_post_5603585438968144214", ios::binary | ios::out);
    	if(outfile__dynamic_array_synapses__synaptic_post.is_open())
    	{
            if (! _dynamic_array_synapses__synaptic_post.empty() )
            {
    			outfile__dynamic_array_synapses__synaptic_post.write(reinterpret_cast<char*>(&_dynamic_array_synapses__synaptic_post[0]), _dynamic_array_synapses__synaptic_post.size()*sizeof(_dynamic_array_synapses__synaptic_post[0]));
    		    outfile__dynamic_array_synapses__synaptic_post.close();
    		}
    	} else
    	{
    		std::cout << "Error writing output file for _dynamic_array_synapses__synaptic_post." << endl;
    	}
    	ofstream outfile__dynamic_array_synapses__synaptic_pre;
    	outfile__dynamic_array_synapses__synaptic_pre.open("results/_dynamic_array_synapses__synaptic_pre_-5759336349697895789", ios::binary | ios::out);
    	if(outfile__dynamic_array_synapses__synaptic_pre.is_open())
    	{
            if (! _dynamic_array_synapses__synaptic_pre.empty() )
            {
    			outfile__dynamic_array_synapses__synaptic_pre.write(reinterpret_cast<char*>(&_dynamic_array_synapses__synaptic_pre[0]), _dynamic_array_synapses__synaptic_pre.size()*sizeof(_dynamic_array_synapses__synaptic_pre[0]));
    		    outfile__dynamic_array_synapses__synaptic_pre.close();
    		}
    	} else
    	{
    		std::cout << "Error writing output file for _dynamic_array_synapses__synaptic_pre." << endl;
    	}
    	ofstream outfile__dynamic_array_synapses_delay;
    	outfile__dynamic_array_synapses_delay.open("results/_dynamic_array_synapses_delay_1467920754926367875", ios::binary | ios::out);
    	if(outfile__dynamic_array_synapses_delay.is_open())
    	{
            if (! _dynamic_array_synapses_delay.empty() )
            {
    			outfile__dynamic_array_synapses_delay.write(reinterpret_cast<char*>(&_dynamic_array_synapses_delay[0]), _dynamic_array_synapses_delay.size()*sizeof(_dynamic_array_synapses_delay[0]));
    		    outfile__dynamic_array_synapses_delay.close();
    		}
    	} else
    	{
    		std::cout << "Error writing output file for _dynamic_array_synapses_delay." << endl;
    	}
    	ofstream outfile__dynamic_array_synapses_lastupdate;
    	outfile__dynamic_array_synapses_lastupdate.open("results/_dynamic_array_synapses_lastupdate_2009503328561562882", ios::binary | ios::out);
    	if(outfile__dynamic_array_synapses_lastupdate.is_open())
    	{
            if (! _dynamic_array_synapses_lastupdate.empty() )
            {
    			outfile__dynamic_array_synapses_lastupdate.write(reinterpret_cast<char*>(&_dynamic_array_synapses_lastupdate[0]), _dynamic_array_synapses_lastupdate.size()*sizeof(_dynamic_array_synapses_lastupdate[0]));
    		    outfile__dynamic_array_synapses_lastupdate.close();
    		}
    	} else
    	{
    		std::cout << "Error writing output file for _dynamic_array_synapses_lastupdate." << endl;
    	}
    	ofstream outfile__dynamic_array_synapses_N_incoming;
    	outfile__dynamic_array_synapses_N_incoming.open("results/_dynamic_array_synapses_N_incoming_5354858401990239730", ios::binary | ios::out);
    	if(outfile__dynamic_array_synapses_N_incoming.is_open())
    	{
            if (! _dynamic_array_synapses_N_incoming.empty() )
            {
    			outfile__dynamic_array_synapses_N_incoming.write(reinterpret_cast<char*>(&_dynamic_array_synapses_N_incoming[0]), _dynamic_array_synapses_N_incoming.size()*sizeof(_dynamic_array_synapses_N_incoming[0]));
    		    outfile__dynamic_array_synapses_N_incoming.close();
    		}
    	} else
    	{
    		std::cout << "Error writing output file for _dynamic_array_synapses_N_incoming." << endl;
    	}
    	ofstream outfile__dynamic_array_synapses_N_outgoing;
    	outfile__dynamic_array_synapses_N_outgoing.open("results/_dynamic_array_synapses_N_outgoing_-3242320671959489857", ios::binary | ios::out);
    	if(outfile__dynamic_array_synapses_N_outgoing.is_open())
    	{
            if (! _dynamic_array_synapses_N_outgoing.empty() )
            {
    			outfile__dynamic_array_synapses_N_outgoing.write(reinterpret_cast<char*>(&_dynamic_array_synapses_N_outgoing[0]), _dynamic_array_synapses_N_outgoing.size()*sizeof(_dynamic_array_synapses_N_outgoing[0]));
    		    outfile__dynamic_array_synapses_N_outgoing.close();
    		}
    	} else
    	{
    		std::cout << "Error writing output file for _dynamic_array_synapses_N_outgoing." << endl;
    	}
    	ofstream outfile__dynamic_array_statemonitor_v;
    	outfile__dynamic_array_statemonitor_v.open("results/_dynamic_array_statemonitor_v_4655625700862555165", ios::binary | ios::out);
    	if(outfile__dynamic_array_statemonitor_v.is_open())
    	{
            for (int n=0; n<_dynamic_array_statemonitor_v.n; n++)
            {
                if (! _dynamic_array_statemonitor_v(n).empty())
                {
                    outfile__dynamic_array_statemonitor_v.write(reinterpret_cast<char*>(&_dynamic_array_statemonitor_v(n, 0)), _dynamic_array_statemonitor_v.m*sizeof(_dynamic_array_statemonitor_v(0, 0)));
                }
            }
            outfile__dynamic_array_statemonitor_v.close();
    	} else
    	{
    		std::cout << "Error writing output file for _dynamic_array_statemonitor_v." << endl;
    	}
    	// Write profiling info to disk
    	ofstream outfile_profiling_info;
    	outfile_profiling_info.open("results/profiling_info.txt", ios::out);
    	if(outfile_profiling_info.is_open())
    	{
    	outfile_profiling_info << "neurongroup_resetter_codeobject\t" << neurongroup_resetter_codeobject_profiling_info << std::endl;
    	outfile_profiling_info << "neurongroup_stateupdater_codeobject\t" << neurongroup_stateupdater_codeobject_profiling_info << std::endl;
    	outfile_profiling_info << "neurongroup_thresholder_codeobject\t" << neurongroup_thresholder_codeobject_profiling_info << std::endl;
    	outfile_profiling_info << "statemonitor_codeobject\t" << statemonitor_codeobject_profiling_info << std::endl;
    	outfile_profiling_info << "synapses_pre_codeobject\t" << synapses_pre_codeobject_profiling_info << std::endl;
    	outfile_profiling_info << "synapses_pre_initialise_queue\t" << synapses_pre_initialise_queue_profiling_info << std::endl;
    	outfile_profiling_info << "synapses_pre_push_spikes\t" << synapses_pre_push_spikes_profiling_info << std::endl;
    	outfile_profiling_info << "synapses_synapses_create_array_codeobject\t" << synapses_synapses_create_array_codeobject_profiling_info << std::endl;
    	outfile_profiling_info.close();
    	} else
    	{
    	    std::cout << "Error writing profiling info to file." << std::endl;
    	}
    	// Write last run info to disk
    	ofstream outfile_last_run_info;
    	outfile_last_run_info.open("results/last_run_info.txt", ios::out);
    	if(outfile_last_run_info.is_open())
    	{
    		outfile_last_run_info << (Network::_last_run_time) << " " << (Network::_last_run_completed_fraction) << std::endl;
    		outfile_last_run_info.close();
    	} else
    	{
    	    std::cout << "Error writing last run info to file." << std::endl;
    	}
    }
    void _dealloc_arrays()
    {
    	using namespace brian;
    	// static arrays
    	if(_static_array__array_neurongroup_I!=0)
    	{
    		delete [] _static_array__array_neurongroup_I;
    		_static_array__array_neurongroup_I = 0;
    	}
    	if(_static_array__array_neurongroup_tau!=0)
    	{
    		delete [] _static_array__array_neurongroup_tau;
    		_static_array__array_neurongroup_tau = 0;
    	}
    	if(_static_array__array_statemonitor__indices!=0)
    	{
    		delete [] _static_array__array_statemonitor__indices;
    		_static_array__array_statemonitor__indices = 0;
    	}
    }
 [brian2.devices.cpp_standalone.device]
DIAGNOSTIC Writing file objects.cpp:

#include "objects.h"
#include "synapses_classes.h"
#include "brianlib/clocks.h"
#include "brianlib/dynamic_array.h"
#include "brianlib/stdint_compat.h"
#include "network.h"
#include "randomkit.h"
#include<vector>
#include<iostream>
#include<fstream>

namespace brian {

std::vector< rk_state* > _mersenne_twister_states;

//////////////// networks /////////////////
Network magicnetwork;

//////////////// arrays ///////////////////
double * _array_defaultclock_dt;
const int _num__array_defaultclock_dt = 1;
double * _array_defaultclock_t;
const int _num__array_defaultclock_t = 1;
int64_t * _array_defaultclock_timestep;
const int _num__array_defaultclock_timestep = 1;
int32_t * _array_neurongroup__spikespace;
const int _num__array_neurongroup__spikespace = 3;
double * _array_neurongroup_I;
const int _num__array_neurongroup_I = 2;
int32_t * _array_neurongroup_i;
const int _num__array_neurongroup_i = 2;
double * _array_neurongroup_tau;
const int _num__array_neurongroup_tau = 2;
double * _array_neurongroup_v;
const int _num__array_neurongroup_v = 2;
int32_t * _array_statemonitor__indices;
const int _num__array_statemonitor__indices = 2;
int32_t * _array_statemonitor_N;
const int _num__array_statemonitor_N = 1;
double * _array_statemonitor_v;
const int _num__array_statemonitor_v = (0, 2);
int32_t * _array_synapses_N;
const int _num__array_synapses_N = 1;
int32_t * _array_synapses_sources;
const int _num__array_synapses_sources = 1;
int32_t * _array_synapses_targets;
const int _num__array_synapses_targets = 1;

//////////////// dynamic arrays 1d /////////
std::vector<double> _dynamic_array_statemonitor_t;
std::vector<int32_t> _dynamic_array_synapses__synaptic_post;
std::vector<int32_t> _dynamic_array_synapses__synaptic_pre;
std::vector<double> _dynamic_array_synapses_delay;
std::vector<double> _dynamic_array_synapses_lastupdate;
std::vector<int32_t> _dynamic_array_synapses_N_incoming;
std::vector<int32_t> _dynamic_array_synapses_N_outgoing;

//////////////// dynamic arrays 2d /////////
DynamicArray2D<double> _dynamic_array_statemonitor_v;

/////////////// static arrays /////////////
int64_t * _static_array__array_neurongroup_I;
const int _num__static_array__array_neurongroup_I = 2;
double * _static_array__array_neurongroup_tau;
const int _num__static_array__array_neurongroup_tau = 2;
int32_t * _static_array__array_statemonitor__indices;
const int _num__static_array__array_statemonitor__indices = 2;

//////////////// synapses /////////////////
// synapses
SynapticPathway<double> synapses_pre(
		_dynamic_array_synapses_delay,
		_dynamic_array_synapses__synaptic_pre,
		0, 2);

//////////////// clocks ///////////////////
Clock defaultclock;  // attributes will be set in run.cpp

// Profiling information for each code object
double neurongroup_resetter_codeobject_profiling_info = 0.0;
double neurongroup_stateupdater_codeobject_profiling_info = 0.0;
double neurongroup_thresholder_codeobject_profiling_info = 0.0;
double statemonitor_codeobject_profiling_info = 0.0;
double synapses_pre_codeobject_profiling_info = 0.0;
double synapses_pre_initialise_queue_profiling_info = 0.0;
double synapses_pre_push_spikes_profiling_info = 0.0;
double synapses_synapses_create_array_codeobject_profiling_info = 0.0;

}

void _init_arrays()
{
	using namespace brian;

    // Arrays initialized to 0
	_array_defaultclock_dt = new double[1];
    
	for(int i=0; i<1; i++) _array_defaultclock_dt[i] = 0;

	_array_defaultclock_t = new double[1];
    
	for(int i=0; i<1; i++) _array_defaultclock_t[i] = 0;

	_array_defaultclock_timestep = new int64_t[1];
    
	for(int i=0; i<1; i++) _array_defaultclock_timestep[i] = 0;

	_array_neurongroup__spikespace = new int32_t[3];
    
	for(int i=0; i<3; i++) _array_neurongroup__spikespace[i] = 0;

	_array_neurongroup_i = new int32_t[2];
    
	for(int i=0; i<2; i++) _array_neurongroup_i[i] = 0;

	_array_neurongroup_I = new double[2];
    
	for(int i=0; i<2; i++) _array_neurongroup_I[i] = 0;

	_array_neurongroup_tau = new double[2];
    
	for(int i=0; i<2; i++) _array_neurongroup_tau[i] = 0;

	_array_neurongroup_v = new double[2];
    
	for(int i=0; i<2; i++) _array_neurongroup_v[i] = 0;

	_array_statemonitor__indices = new int32_t[2];
    
	for(int i=0; i<2; i++) _array_statemonitor__indices[i] = 0;

	_array_statemonitor_N = new int32_t[1];
    
	for(int i=0; i<1; i++) _array_statemonitor_N[i] = 0;

	_array_synapses_N = new int32_t[1];
    
	for(int i=0; i<1; i++) _array_synapses_N[i] = 0;

	_array_synapses_sources = new int32_t[1];
    
	for(int i=0; i<1; i++) _array_synapses_sources[i] = 0;

	_array_synapses_targets = new int32_t[1];
    
	for(int i=0; i<1; i++) _array_synapses_targets[i] = 0;


	// Arrays initialized to an "arange"
	_array_neurongroup_i = new int32_t[2];
    
	for(int i=0; i<2; i++) _array_neurongroup_i[i] = 0 + i;


	// static arrays
	_static_array__array_neurongroup_I = new int64_t[2];
	_static_array__array_neurongroup_tau = new double[2];
	_static_array__array_statemonitor__indices = new int32_t[2];

	// Random number generator states
	for (int i=0; i<1; i++)
	    _mersenne_twister_states.push_back(new rk_state());
}

void _load_arrays()
{
	using namespace brian;

	ifstream f_static_array__array_neurongroup_I;
	f_static_array__array_neurongroup_I.open("static_arrays/_static_array__array_neurongroup_I", ios::in | ios::binary);
	if(f_static_array__array_neurongroup_I.is_open())
	{
		f_static_array__array_neurongroup_I.read(reinterpret_cast<char*>(_static_array__array_neurongroup_I), 2*sizeof(int64_t));
	} else
	{
		std::cout << "Error opening static array _static_array__array_neurongroup_I." << endl;
	}
	ifstream f_static_array__array_neurongroup_tau;
	f_static_array__array_neurongroup_tau.open("static_arrays/_static_array__array_neurongroup_tau", ios::in | ios::binary);
	if(f_static_array__array_neurongroup_tau.is_open())
	{
		f_static_array__array_neurongroup_tau.read(reinterpret_cast<char*>(_static_array__array_neurongroup_tau), 2*sizeof(double));
	} else
	{
		std::cout << "Error opening static array _static_array__array_neurongroup_tau." << endl;
	}
	ifstream f_static_array__array_statemonitor__indices;
	f_static_array__array_statemonitor__indices.open("static_arrays/_static_array__array_statemonitor__indices", ios::in | ios::binary);
	if(f_static_array__array_statemonitor__indices.is_open())
	{
		f_static_array__array_statemonitor__indices.read(reinterpret_cast<char*>(_static_array__array_statemonitor__indices), 2*sizeof(int32_t));
	} else
	{
		std::cout << "Error opening static array _static_array__array_statemonitor__indices." << endl;
	}
}

void _write_arrays()
{
	using namespace brian;

	ofstream outfile__array_defaultclock_dt;
	outfile__array_defaultclock_dt.open("results/_array_defaultclock_dt_3747468184395835432", ios::binary | ios::out);
	if(outfile__array_defaultclock_dt.is_open())
	{
		outfile__array_defaultclock_dt.write(reinterpret_cast<char*>(_array_defaultclock_dt), 1*sizeof(_array_defaultclock_dt[0]));
		outfile__array_defaultclock_dt.close();
	} else
	{
		std::cout << "Error writing output file for _array_defaultclock_dt." << endl;
	}
	ofstream outfile__array_defaultclock_t;
	outfile__array_defaultclock_t.open("results/_array_defaultclock_t_-7115825036261727037", ios::binary | ios::out);
	if(outfile__array_defaultclock_t.is_open())
	{
		outfile__array_defaultclock_t.write(reinterpret_cast<char*>(_array_defaultclock_t), 1*sizeof(_array_defaultclock_t[0]));
		outfile__array_defaultclock_t.close();
	} else
	{
		std::cout << "Error writing output file for _array_defaultclock_t." << endl;
	}
	ofstream outfile__array_defaultclock_timestep;
	outfile__array_defaultclock_timestep.open("results/_array_defaultclock_timestep_2633846103642586746", ios::binary | ios::out);
	if(outfile__array_defaultclock_timestep.is_open())
	{
		outfile__array_defaultclock_timestep.write(reinterpret_cast<char*>(_array_defaultclock_timestep), 1*sizeof(_array_defaultclock_timestep[0]));
		outfile__array_defaultclock_timestep.close();
	} else
	{
		std::cout << "Error writing output file for _array_defaultclock_timestep." << endl;
	}
	ofstream outfile__array_neurongroup__spikespace;
	outfile__array_neurongroup__spikespace.open("results/_array_neurongroup__spikespace_573674353579096559", ios::binary | ios::out);
	if(outfile__array_neurongroup__spikespace.is_open())
	{
		outfile__array_neurongroup__spikespace.write(reinterpret_cast<char*>(_array_neurongroup__spikespace), 3*sizeof(_array_neurongroup__spikespace[0]));
		outfile__array_neurongroup__spikespace.close();
	} else
	{
		std::cout << "Error writing output file for _array_neurongroup__spikespace." << endl;
	}
	ofstream outfile__array_neurongroup_I;
	outfile__array_neurongroup_I.open("results/_array_neurongroup_I_-1901320210814771266", ios::binary | ios::out);
	if(outfile__array_neurongroup_I.is_open())
	{
		outfile__array_neurongroup_I.write(reinterpret_cast<char*>(_array_neurongroup_I), 2*sizeof(_array_neurongroup_I[0]));
		outfile__array_neurongroup_I.close();
	} else
	{
		std::cout << "Error writing output file for _array_neurongroup_I." << endl;
	}
	ofstream outfile__array_neurongroup_i;
	outfile__array_neurongroup_i.open("results/_array_neurongroup_i_-4028626282186028042", ios::binary | ios::out);
	if(outfile__array_neurongroup_i.is_open())
	{
		outfile__array_neurongroup_i.write(reinterpret_cast<char*>(_array_neurongroup_i), 2*sizeof(_array_neurongroup_i[0]));
		outfile__array_neurongroup_i.close();
	} else
	{
		std::cout << "Error writing output file for _array_neurongroup_i." << endl;
	}
	ofstream outfile__array_neurongroup_tau;
	outfile__array_neurongroup_tau.open("results/_array_neurongroup_tau_-1492113667029771614", ios::binary | ios::out);
	if(outfile__array_neurongroup_tau.is_open())
	{
		outfile__array_neurongroup_tau.write(reinterpret_cast<char*>(_array_neurongroup_tau), 2*sizeof(_array_neurongroup_tau[0]));
		outfile__array_neurongroup_tau.close();
	} else
	{
		std::cout << "Error writing output file for _array_neurongroup_tau." << endl;
	}
	ofstream outfile__array_neurongroup_v;
	outfile__array_neurongroup_v.open("results/_array_neurongroup_v_-5500494582704731642", ios::binary | ios::out);
	if(outfile__array_neurongroup_v.is_open())
	{
		outfile__array_neurongroup_v.write(reinterpret_cast<char*>(_array_neurongroup_v), 2*sizeof(_array_neurongroup_v[0]));
		outfile__array_neurongroup_v.close();
	} else
	{
		std::cout << "Error writing output file for _array_neurongroup_v." << endl;
	}
	ofstream outfile__array_statemonitor__indices;
	outfile__array_statemonitor__indices.open("results/_array_statemonitor__indices_-1442741383992362881", ios::binary | ios::out);
	if(outfile__array_statemonitor__indices.is_open())
	{
		outfile__array_statemonitor__indices.write(reinterpret_cast<char*>(_array_statemonitor__indices), 2*sizeof(_array_statemonitor__indices[0]));
		outfile__array_statemonitor__indices.close();
	} else
	{
		std::cout << "Error writing output file for _array_statemonitor__indices." << endl;
	}
	ofstream outfile__array_statemonitor_N;
	outfile__array_statemonitor_N.open("results/_array_statemonitor_N_3852463596759852795", ios::binary | ios::out);
	if(outfile__array_statemonitor_N.is_open())
	{
		outfile__array_statemonitor_N.write(reinterpret_cast<char*>(_array_statemonitor_N), 1*sizeof(_array_statemonitor_N[0]));
		outfile__array_statemonitor_N.close();
	} else
	{
		std::cout << "Error writing output file for _array_statemonitor_N." << endl;
	}
	ofstream outfile__array_synapses_N;
	outfile__array_synapses_N.open("results/_array_synapses_N_5284365010639707735", ios::binary | ios::out);
	if(outfile__array_synapses_N.is_open())
	{
		outfile__array_synapses_N.write(reinterpret_cast<char*>(_array_synapses_N), 1*sizeof(_array_synapses_N[0]));
		outfile__array_synapses_N.close();
	} else
	{
		std::cout << "Error writing output file for _array_synapses_N." << endl;
	}
	ofstream outfile__array_synapses_sources;
	outfile__array_synapses_sources.open("results/_array_synapses_sources_-4112904328018476915", ios::binary | ios::out);
	if(outfile__array_synapses_sources.is_open())
	{
		outfile__array_synapses_sources.write(reinterpret_cast<char*>(_array_synapses_sources), 1*sizeof(_array_synapses_sources[0]));
		outfile__array_synapses_sources.close();
	} else
	{
		std::cout << "Error writing output file for _array_synapses_sources." << endl;
	}
	ofstream outfile__array_synapses_targets;
	outfile__array_synapses_targets.open("results/_array_synapses_targets_-6890910146927201111", ios::binary | ios::out);
	if(outfile__array_synapses_targets.is_open())
	{
		outfile__array_synapses_targets.write(reinterpret_cast<char*>(_array_synapses_targets), 1*sizeof(_array_synapses_targets[0]));
		outfile__array_synapses_targets.close();
	} else
	{
		std::cout << "Error writing output file for _array_synapses_targets." << endl;
	}

	ofstream outfile__dynamic_array_statemonitor_t;
	outfile__dynamic_array_statemonitor_t.open("results/_dynamic_array_statemonitor_t_1033670080024100330", ios::binary | ios::out);
	if(outfile__dynamic_array_statemonitor_t.is_open())
	{
        if (! _dynamic_array_statemonitor_t.empty() )
        {
			outfile__dynamic_array_statemonitor_t.write(reinterpret_cast<char*>(&_dynamic_array_statemonitor_t[0]), _dynamic_array_statemonitor_t.size()*sizeof(_dynamic_array_statemonitor_t[0]));
		    outfile__dynamic_array_statemonitor_t.close();
		}
	} else
	{
		std::cout << "Error writing output file for _dynamic_array_statemonitor_t." << endl;
	}
	ofstream outfile__dynamic_array_synapses__synaptic_post;
	outfile__dynamic_array_synapses__synaptic_post.open("results/_dynamic_array_synapses__synaptic_post_5603585438968144214", ios::binary | ios::out);
	if(outfile__dynamic_array_synapses__synaptic_post.is_open())
	{
        if (! _dynamic_array_synapses__synaptic_post.empty() )
        {
			outfile__dynamic_array_synapses__synaptic_post.write(reinterpret_cast<char*>(&_dynamic_array_synapses__synaptic_post[0]), _dynamic_array_synapses__synaptic_post.size()*sizeof(_dynamic_array_synapses__synaptic_post[0]));
		    outfile__dynamic_array_synapses__synaptic_post.close();
		}
	} else
	{
		std::cout << "Error writing output file for _dynamic_array_synapses__synaptic_post." << endl;
	}
	ofstream outfile__dynamic_array_synapses__synaptic_pre;
	outfile__dynamic_array_synapses__synaptic_pre.open("results/_dynamic_array_synapses__synaptic_pre_-5759336349697895789", ios::binary | ios::out);
	if(outfile__dynamic_array_synapses__synaptic_pre.is_open())
	{
        if (! _dynamic_array_synapses__synaptic_pre.empty() )
        {
			outfile__dynamic_array_synapses__synaptic_pre.write(reinterpret_cast<char*>(&_dynamic_array_synapses__synaptic_pre[0]), _dynamic_array_synapses__synaptic_pre.size()*sizeof(_dynamic_array_synapses__synaptic_pre[0]));
		    outfile__dynamic_array_synapses__synaptic_pre.close();
		}
	} else
	{
		std::cout << "Error writing output file for _dynamic_array_synapses__synaptic_pre." << endl;
	}
	ofstream outfile__dynamic_array_synapses_delay;
	outfile__dynamic_array_synapses_delay.open("results/_dynamic_array_synapses_delay_1467920754926367875", ios::binary | ios::out);
	if(outfile__dynamic_array_synapses_delay.is_open())
	{
        if (! _dynamic_array_synapses_delay.empty() )
        {
			outfile__dynamic_array_synapses_delay.write(reinterpret_cast<char*>(&_dynamic_array_synapses_delay[0]), _dynamic_array_synapses_delay.size()*sizeof(_dynamic_array_synapses_delay[0]));
		    outfile__dynamic_array_synapses_delay.close();
		}
	} else
	{
		std::cout << "Error writing output file for _dynamic_array_synapses_delay." << endl;
	}
	ofstream outfile__dynamic_array_synapses_lastupdate;
	outfile__dynamic_array_synapses_lastupdate.open("results/_dynamic_array_synapses_lastupdate_2009503328561562882", ios::binary | ios::out);
	if(outfile__dynamic_array_synapses_lastupdate.is_open())
	{
        if (! _dynamic_array_synapses_lastupdate.empty() )
        {
			outfile__dynamic_array_synapses_lastupdate.write(reinterpret_cast<char*>(&_dynamic_array_synapses_lastupdate[0]), _dynamic_array_synapses_lastupdate.size()*sizeof(_dynamic_array_synapses_lastupdate[0]));
		    outfile__dynamic_array_synapses_lastupdate.close();
		}
	} else
	{
		std::cout << "Error writing output file for _dynamic_array_synapses_lastupdate." << endl;
	}
	ofstream outfile__dynamic_array_synapses_N_incoming;
	outfile__dynamic_array_synapses_N_incoming.open("results/_dynamic_array_synapses_N_incoming_5354858401990239730", ios::binary | ios::out);
	if(outfile__dynamic_array_synapses_N_incoming.is_open())
	{
        if (! _dynamic_array_synapses_N_incoming.empty() )
        {
			outfile__dynamic_array_synapses_N_incoming.write(reinterpret_cast<char*>(&_dynamic_array_synapses_N_incoming[0]), _dynamic_array_synapses_N_incoming.size()*sizeof(_dynamic_array_synapses_N_incoming[0]));
		    outfile__dynamic_array_synapses_N_incoming.close();
		}
	} else
	{
		std::cout << "Error writing output file for _dynamic_array_synapses_N_incoming." << endl;
	}
	ofstream outfile__dynamic_array_synapses_N_outgoing;
	outfile__dynamic_array_synapses_N_outgoing.open("results/_dynamic_array_synapses_N_outgoing_-3242320671959489857", ios::binary | ios::out);
	if(outfile__dynamic_array_synapses_N_outgoing.is_open())
	{
        if (! _dynamic_array_synapses_N_outgoing.empty() )
        {
			outfile__dynamic_array_synapses_N_outgoing.write(reinterpret_cast<char*>(&_dynamic_array_synapses_N_outgoing[0]), _dynamic_array_synapses_N_outgoing.size()*sizeof(_dynamic_array_synapses_N_outgoing[0]));
		    outfile__dynamic_array_synapses_N_outgoing.close();
		}
	} else
	{
		std::cout << "Error writing output file for _dynamic_array_synapses_N_outgoing." << endl;
	}

	ofstream outfile__dynamic_array_statemonitor_v;
	outfile__dynamic_array_statemonitor_v.open("results/_dynamic_array_statemonitor_v_4655625700862555165", ios::binary | ios::out);
	if(outfile__dynamic_array_statemonitor_v.is_open())
	{
        for (int n=0; n<_dynamic_array_statemonitor_v.n; n++)
        {
            if (! _dynamic_array_statemonitor_v(n).empty())
            {
                outfile__dynamic_array_statemonitor_v.write(reinterpret_cast<char*>(&_dynamic_array_statemonitor_v(n, 0)), _dynamic_array_statemonitor_v.m*sizeof(_dynamic_array_statemonitor_v(0, 0)));
            }
        }
        outfile__dynamic_array_statemonitor_v.close();
	} else
	{
		std::cout << "Error writing output file for _dynamic_array_statemonitor_v." << endl;
	}

	// Write profiling info to disk
	ofstream outfile_profiling_info;
	outfile_profiling_info.open("results/profiling_info.txt", ios::out);
	if(outfile_profiling_info.is_open())
	{
	outfile_profiling_info << "neurongroup_resetter_codeobject\t" << neurongroup_resetter_codeobject_profiling_info << std::endl;
	outfile_profiling_info << "neurongroup_stateupdater_codeobject\t" << neurongroup_stateupdater_codeobject_profiling_info << std::endl;
	outfile_profiling_info << "neurongroup_thresholder_codeobject\t" << neurongroup_thresholder_codeobject_profiling_info << std::endl;
	outfile_profiling_info << "statemonitor_codeobject\t" << statemonitor_codeobject_profiling_info << std::endl;
	outfile_profiling_info << "synapses_pre_codeobject\t" << synapses_pre_codeobject_profiling_info << std::endl;
	outfile_profiling_info << "synapses_pre_initialise_queue\t" << synapses_pre_initialise_queue_profiling_info << std::endl;
	outfile_profiling_info << "synapses_pre_push_spikes\t" << synapses_pre_push_spikes_profiling_info << std::endl;
	outfile_profiling_info << "synapses_synapses_create_array_codeobject\t" << synapses_synapses_create_array_codeobject_profiling_info << std::endl;
	outfile_profiling_info.close();
	} else
	{
	    std::cout << "Error writing profiling info to file." << std::endl;
	}

	// Write last run info to disk
	ofstream outfile_last_run_info;
	outfile_last_run_info.open("results/last_run_info.txt", ios::out);
	if(outfile_last_run_info.is_open())
	{
		outfile_last_run_info << (Network::_last_run_time) << " " << (Network::_last_run_completed_fraction) << std::endl;
		outfile_last_run_info.close();
	} else
	{
	    std::cout << "Error writing last run info to file." << std::endl;
	}
}

void _dealloc_arrays()
{
	using namespace brian;


	// static arrays
	if(_static_array__array_neurongroup_I!=0)
	{
		delete [] _static_array__array_neurongroup_I;
		_static_array__array_neurongroup_I = 0;
	}
	if(_static_array__array_neurongroup_tau!=0)
	{
		delete [] _static_array__array_neurongroup_tau;
		_static_array__array_neurongroup_tau = 0;
	}
	if(_static_array__array_statemonitor__indices!=0)
	{
		delete [] _static_array__array_statemonitor__indices;
		_static_array__array_statemonitor__indices = 0;
	}
}

 [brian2.devices.cpp_standalone.device]
DIAGNOSTIC Writing file objects.h:

#ifndef _BRIAN_OBJECTS_H
#define _BRIAN_OBJECTS_H

#include "synapses_classes.h"
#include "brianlib/clocks.h"
#include "brianlib/dynamic_array.h"
#include "brianlib/stdint_compat.h"
#include "network.h"
#include "randomkit.h"
#include<vector>


namespace brian {

// In OpenMP we need one state per thread
extern std::vector< rk_state* > _mersenne_twister_states;

//////////////// clocks ///////////////////
extern Clock defaultclock;

//////////////// networks /////////////////
extern Network magicnetwork;

//////////////// dynamic arrays ///////////
extern std::vector<double> _dynamic_array_statemonitor_t;
extern std::vector<int32_t> _dynamic_array_synapses__synaptic_post;
extern std::vector<int32_t> _dynamic_array_synapses__synaptic_pre;
extern std::vector<double> _dynamic_array_synapses_delay;
extern std::vector<double> _dynamic_array_synapses_lastupdate;
extern std::vector<int32_t> _dynamic_array_synapses_N_incoming;
extern std::vector<int32_t> _dynamic_array_synapses_N_outgoing;

//////////////// arrays ///////////////////
extern double *_array_defaultclock_dt;
extern const int _num__array_defaultclock_dt;
extern double *_array_defaultclock_t;
extern const int _num__array_defaultclock_t;
extern int64_t *_array_defaultclock_timestep;
extern const int _num__array_defaultclock_timestep;
extern int32_t *_array_neurongroup__spikespace;
extern const int _num__array_neurongroup__spikespace;
extern double *_array_neurongroup_I;
extern const int _num__array_neurongroup_I;
extern int32_t *_array_neurongroup_i;
extern const int _num__array_neurongroup_i;
extern double *_array_neurongroup_tau;
extern const int _num__array_neurongroup_tau;
extern double *_array_neurongroup_v;
extern const int _num__array_neurongroup_v;
extern int32_t *_array_statemonitor__indices;
extern const int _num__array_statemonitor__indices;
extern int32_t *_array_statemonitor_N;
extern const int _num__array_statemonitor_N;
extern double *_array_statemonitor_v;
extern const int _num__array_statemonitor_v;
extern int32_t *_array_synapses_N;
extern const int _num__array_synapses_N;
extern int32_t *_array_synapses_sources;
extern const int _num__array_synapses_sources;
extern int32_t *_array_synapses_targets;
extern const int _num__array_synapses_targets;

//////////////// dynamic arrays 2d /////////
extern DynamicArray2D<double> _dynamic_array_statemonitor_v;

/////////////// static arrays /////////////
extern int64_t *_static_array__array_neurongroup_I;
extern const int _num__static_array__array_neurongroup_I;
extern double *_static_array__array_neurongroup_tau;
extern const int _num__static_array__array_neurongroup_tau;
extern int32_t *_static_array__array_statemonitor__indices;
extern const int _num__static_array__array_statemonitor__indices;

//////////////// synapses /////////////////
// synapses
extern SynapticPathway<double> synapses_pre;

// Profiling information for each code object
extern double neurongroup_resetter_codeobject_profiling_info;
extern double neurongroup_stateupdater_codeobject_profiling_info;
extern double neurongroup_thresholder_codeobject_profiling_info;
extern double statemonitor_codeobject_profiling_info;
extern double synapses_pre_codeobject_profiling_info;
extern double synapses_pre_initialise_queue_profiling_info;
extern double synapses_pre_push_spikes_profiling_info;
extern double synapses_synapses_create_array_codeobject_profiling_info;

}

void _init_arrays();
void _load_arrays();
void _write_arrays();
void _dealloc_arrays();

#endif


 [brian2.devices.cpp_standalone.device]
DIAGNOSTIC Writing file main.cpp:
#include <stdlib.h>
#include "objects.h"
#include <ctime>
#include <time.h>

#include "run.h"
#include "brianlib/common_math.h"
#include "randomkit.h"

#include "code_objects/neurongroup_resetter_codeobject.h"
#include "code_objects/neurongroup_stateupdater_codeobject.h"
#include "code_objects/neurongroup_thresholder_codeobject.h"
#include "code_objects/statemonitor_codeobject.h"
#include "code_objects/synapses_pre_codeobject.h"
#include "code_objects/synapses_pre_initialise_queue.h"
#include "code_objects/synapses_pre_push_spikes.h"
#include "code_objects/synapses_synapses_create_array_codeobject.h"


#include <iostream>
#include <fstream>




int main(int argc, char **argv)
{

	brian_start();

	{
		using namespace brian;

		
                
        _array_defaultclock_dt[0] = 0.0001;
        _array_defaultclock_dt[0] = 0.0001;
        _array_defaultclock_dt[0] = 0.0001;
        
                        
                        for(int i=0; i<_num__array_neurongroup_I; i++)
                        {
                            _array_neurongroup_I[i] = _static_array__array_neurongroup_I[i];
                        }
                        
        
                        
                        for(int i=0; i<_num__array_neurongroup_tau; i++)
                        {
                            _array_neurongroup_tau[i] = _static_array__array_neurongroup_tau[i];
                        }
                        
        _array_synapses_sources[0] = 0;
        _array_synapses_targets[0] = 1;
        _run_synapses_synapses_create_array_codeobject();
        
                        
                        for(int i=0; i<_num__array_statemonitor__indices; i++)
                        {
                            _array_statemonitor__indices[i] = _static_array__array_statemonitor__indices[i];
                        }
                        
        _array_defaultclock_timestep[0] = 0;
        _array_defaultclock_t[0] = 0.0;
        _run_synapses_pre_initialise_queue();
        magicnetwork.clear();
        magicnetwork.add(&defaultclock, _run_statemonitor_codeobject);
        magicnetwork.add(&defaultclock, _run_neurongroup_stateupdater_codeobject);
        magicnetwork.add(&defaultclock, _run_neurongroup_thresholder_codeobject);
        magicnetwork.add(&defaultclock, _run_synapses_pre_push_spikes);
        magicnetwork.add(&defaultclock, _run_synapses_pre_codeobject);
        magicnetwork.add(&defaultclock, _run_neurongroup_resetter_codeobject);
        magicnetwork.run(0.2, NULL, 10.0);
        #ifdef DEBUG
        _debugmsg_synapses_pre_codeobject();
        #endif

	}

	brian_end();

	return 0;
} [brian2.devices.cpp_standalone.device]
DIAGNOSTIC Writing file code_objects/neurongroup_resetter_codeobject.cpp:
#include "objects.h"
#include "code_objects/neurongroup_resetter_codeobject.h"
#include "brianlib/common_math.h"
#include "brianlib/stdint_compat.h"
#include<cmath>
#include<ctime>
#include<iostream>
#include<fstream>

////// SUPPORT CODE ///////
namespace {
 	
 inline int _brian_mod(int ux, int uy)
 {
     const int x = (int)ux;
     const int y = (int)uy;
     return ((x%y)+y)%y;
 }
 inline long _brian_mod(int ux, long uy)
 {
     const long x = (long)ux;
     const long y = (long)uy;
     return ((x%y)+y)%y;
 }
 inline long long _brian_mod(int ux, long long uy)
 {
     const long long x = (long long)ux;
     const long long y = (long long)uy;
     return ((x%y)+y)%y;
 }
 inline float _brian_mod(int ux, float uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(int ux, double uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(int ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long _brian_mod(long ux, int uy)
 {
     const long x = (long)ux;
     const long y = (long)uy;
     return ((x%y)+y)%y;
 }
 inline long _brian_mod(long ux, long uy)
 {
     const long x = (long)ux;
     const long y = (long)uy;
     return ((x%y)+y)%y;
 }
 inline long long _brian_mod(long ux, long long uy)
 {
     const long long x = (long long)ux;
     const long long y = (long long)uy;
     return ((x%y)+y)%y;
 }
 inline float _brian_mod(long ux, float uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(long ux, double uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long long _brian_mod(long long ux, int uy)
 {
     const long long x = (long long)ux;
     const long long y = (long long)uy;
     return ((x%y)+y)%y;
 }
 inline long long _brian_mod(long long ux, long uy)
 {
     const long long x = (long long)ux;
     const long long y = (long long)uy;
     return ((x%y)+y)%y;
 }
 inline long long _brian_mod(long long ux, long long uy)
 {
     const long long x = (long long)ux;
     const long long y = (long long)uy;
     return ((x%y)+y)%y;
 }
 inline float _brian_mod(long long ux, float uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(long long ux, double uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long long ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline float _brian_mod(float ux, int uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline float _brian_mod(float ux, long uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline float _brian_mod(float ux, long long uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline float _brian_mod(float ux, float uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(float ux, double uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(float ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(double ux, int uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(double ux, long uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(double ux, long long uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(double ux, float uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(double ux, double uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(double ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, int uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, long uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, long long uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, float uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 #ifdef _MSC_VER
 #define _brian_pow(x, y) (pow((double)(x), (y)))
 #else
 #define _brian_pow(x, y) (pow((x), (y)))
 #endif

}

////// HASH DEFINES ///////



void _run_neurongroup_resetter_codeobject()
{
	using namespace brian;

    const std::clock_t _start_time = std::clock();

	///// CONSTANTS ///////////
	const int _numv = 2;
const int _num_spikespace = 3;
	///// POINTERS ////////////
 	
 double* __restrict  _ptr_array_neurongroup_v = _array_neurongroup_v;
 int32_t* __restrict  _ptr_array_neurongroup__spikespace = _array_neurongroup__spikespace;



	const int32_t *_events = _ptr_array_neurongroup__spikespace;
	const int32_t _num_events = _ptr_array_neurongroup__spikespace[2];

	//// MAIN CODE ////////////	
	// scalar code
	const int _vectorisation_idx = -1;
 	


	
	for(int _index_events=0; _index_events<_num_events; _index_events++)
	{
	    // vector code
		const int _idx = _events[_index_events];
		const int _vectorisation_idx = _idx;
                
        double v;
        v = 0;
        _ptr_array_neurongroup_v[_idx] = v;

	}

    const double _run_time = (double)(std::clock() -_start_time)/CLOCKS_PER_SEC;
    neurongroup_resetter_codeobject_profiling_info += _run_time;
}


 [brian2.devices.cpp_standalone.device]
DIAGNOSTIC Writing file code_objects/neurongroup_resetter_codeobject.h:
#ifndef _INCLUDED_neurongroup_resetter_codeobject
#define _INCLUDED_neurongroup_resetter_codeobject

#include "objects.h"

void _run_neurongroup_resetter_codeobject();


#endif
 [brian2.devices.cpp_standalone.device]
DIAGNOSTIC Writing file code_objects/statemonitor_codeobject.cpp:
#include "objects.h"
#include "code_objects/statemonitor_codeobject.h"
#include "brianlib/common_math.h"
#include "brianlib/stdint_compat.h"
#include<cmath>
#include<ctime>
#include<iostream>
#include<fstream>

////// SUPPORT CODE ///////
namespace {
 	
 inline int _brian_mod(int ux, int uy)
 {
     const int x = (int)ux;
     const int y = (int)uy;
     return ((x%y)+y)%y;
 }
 inline long _brian_mod(int ux, long uy)
 {
     const long x = (long)ux;
     const long y = (long)uy;
     return ((x%y)+y)%y;
 }
 inline long long _brian_mod(int ux, long long uy)
 {
     const long long x = (long long)ux;
     const long long y = (long long)uy;
     return ((x%y)+y)%y;
 }
 inline float _brian_mod(int ux, float uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(int ux, double uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(int ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long _brian_mod(long ux, int uy)
 {
     const long x = (long)ux;
     const long y = (long)uy;
     return ((x%y)+y)%y;
 }
 inline long _brian_mod(long ux, long uy)
 {
     const long x = (long)ux;
     const long y = (long)uy;
     return ((x%y)+y)%y;
 }
 inline long long _brian_mod(long ux, long long uy)
 {
     const long long x = (long long)ux;
     const long long y = (long long)uy;
     return ((x%y)+y)%y;
 }
 inline float _brian_mod(long ux, float uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(long ux, double uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long long _brian_mod(long long ux, int uy)
 {
     const long long x = (long long)ux;
     const long long y = (long long)uy;
     return ((x%y)+y)%y;
 }
 inline long long _brian_mod(long long ux, long uy)
 {
     const long long x = (long long)ux;
     const long long y = (long long)uy;
     return ((x%y)+y)%y;
 }
 inline long long _brian_mod(long long ux, long long uy)
 {
     const long long x = (long long)ux;
     const long long y = (long long)uy;
     return ((x%y)+y)%y;
 }
 inline float _brian_mod(long long ux, float uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(long long ux, double uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long long ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline float _brian_mod(float ux, int uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline float _brian_mod(float ux, long uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline float _brian_mod(float ux, long long uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline float _brian_mod(float ux, float uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(float ux, double uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(float ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(double ux, int uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(double ux, long uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(double ux, long long uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(double ux, float uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(double ux, double uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(double ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, int uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, long uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, long long uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, float uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 #ifdef _MSC_VER
 #define _brian_pow(x, y) (pow((double)(x), (y)))
 #else
 #define _brian_pow(x, y) (pow((x), (y)))
 #endif

}

////// HASH DEFINES ///////



void _run_statemonitor_codeobject()
{
	using namespace brian;

    const std::clock_t _start_time = std::clock();

	///// CONSTANTS ///////////
	const int _num_indices = 2;
const int _num_clock_t = 1;
double* const _array_statemonitor_t = _dynamic_array_statemonitor_t.empty()? 0 : &_dynamic_array_statemonitor_t[0];
const int _numt = _dynamic_array_statemonitor_t.size();
const int _num_source_v = 2;
const int _numN = 1;
	///// POINTERS ////////////
 	
 int32_t* __restrict  _ptr_array_statemonitor__indices = _array_statemonitor__indices;
 double*   _ptr_array_defaultclock_t = _array_defaultclock_t;
 double* __restrict  _ptr_array_statemonitor_t = _array_statemonitor_t;
 double* __restrict  _ptr_array_neurongroup_v = _array_neurongroup_v;
 int32_t*   _ptr_array_statemonitor_N = _array_statemonitor_N;



    _dynamic_array_statemonitor_t.push_back(_ptr_array_defaultclock_t[0]);

    const int _new_size = _dynamic_array_statemonitor_t.size();
    // Resize the dynamic arrays
    _dynamic_array_statemonitor_v.resize(_new_size, _num_indices);

    // scalar code
    const int _vectorisation_idx = -1;
        


    
    for (int _i = 0; _i < _num_indices; _i++)
    {
        // vector code
        const int _idx = _ptr_array_statemonitor__indices[_i];
        const int _vectorisation_idx = _idx;
                                        
                    const double _source_v = _ptr_array_neurongroup_v[_idx];
                    const double _to_record_v = _source_v;



            _dynamic_array_statemonitor_v(_new_size-1, _i) = _to_record_v;
    }

    _ptr_array_statemonitor_N[0] = _new_size;


    const double _run_time = (double)(std::clock() -_start_time)/CLOCKS_PER_SEC;
    statemonitor_codeobject_profiling_info += _run_time;
}


 [brian2.devices.cpp_standalone.device]
DIAGNOSTIC Writing file code_objects/statemonitor_codeobject.h:
#ifndef _INCLUDED_statemonitor_codeobject
#define _INCLUDED_statemonitor_codeobject

#include "objects.h"

void _run_statemonitor_codeobject();


#endif
 [brian2.devices.cpp_standalone.device]
DIAGNOSTIC Writing file code_objects/synapses_pre_push_spikes.cpp:
#include "objects.h"
#include "code_objects/synapses_pre_push_spikes.h"
#include "brianlib/common_math.h"
#include "brianlib/stdint_compat.h"
#include<cmath>
#include<ctime>

void _run_synapses_pre_push_spikes()
{
    using namespace brian;

    const std::clock_t _start_time = std::clock();

    ///// CONSTANTS ///////////
    const int _num_spikespace = 3;
    ///// POINTERS ////////////
        
    int32_t* __restrict  _ptr_array_neurongroup__spikespace = _array_neurongroup__spikespace;


    //// MAIN CODE ////////////
    // we do advance at the beginning rather than at the end because it saves us making
    // a copy of the current spiking synapses
    
    {
        synapses_pre.advance();
        synapses_pre.push(_ptr_array_neurongroup__spikespace, _ptr_array_neurongroup__spikespace[_num_spikespace-1]);
    }

    // Profiling
    const double _run_time = (double)(std::clock() -_start_time)/CLOCKS_PER_SEC;
    synapses_pre_push_spikes_profiling_info += _run_time;
}
 [brian2.devices.cpp_standalone.device]
DIAGNOSTIC Writing file code_objects/synapses_pre_push_spikes.h:
#ifndef _INCLUDED_synapses_pre_push_spikes
#define _INCLUDED_synapses_pre_push_spikes

#include "objects.h"

void _run_synapses_pre_push_spikes();

#endif
 [brian2.devices.cpp_standalone.device]
DIAGNOSTIC Writing file code_objects/synapses_pre_initialise_queue.cpp:
#include "objects.h"
#include "code_objects/synapses_pre_initialise_queue.h"
void _run_synapses_pre_initialise_queue() {
	using namespace brian;
 	
 double*   _ptr_array_defaultclock_dt = _array_defaultclock_dt;


    double* real_delays = synapses_pre.delay.empty() ? 0 : &(synapses_pre.delay[0]);
    int32_t* sources = synapses_pre.sources.empty() ? 0 : &(synapses_pre.sources[0]);
    const unsigned int n_delays = synapses_pre.delay.size();
    const unsigned int n_synapses = synapses_pre.sources.size();
    synapses_pre.prepare(2,
                        2,
                        real_delays, n_delays, sources,
                        n_synapses,
                        _ptr_array_defaultclock_dt[0]);
}
 [brian2.devices.cpp_standalone.device]
DIAGNOSTIC Writing file code_objects/synapses_pre_initialise_queue.h:
#ifndef _INCLUDED_synapses_pre_initialise_queue
#define _INCLUDED_synapses_pre_initialise_queue

void _run_synapses_pre_initialise_queue();

#endif
 [brian2.devices.cpp_standalone.device]
DIAGNOSTIC Writing file code_objects/synapses_synapses_create_array_codeobject.cpp:
#include "objects.h"
#include "code_objects/synapses_synapses_create_array_codeobject.h"
#include "brianlib/common_math.h"
#include "brianlib/stdint_compat.h"
#include<cmath>
#include<ctime>
#include<iostream>
#include<fstream>

////// SUPPORT CODE ///////
namespace {
 	
 inline int _brian_mod(int ux, int uy)
 {
     const int x = (int)ux;
     const int y = (int)uy;
     return ((x%y)+y)%y;
 }
 inline long _brian_mod(int ux, long uy)
 {
     const long x = (long)ux;
     const long y = (long)uy;
     return ((x%y)+y)%y;
 }
 inline long long _brian_mod(int ux, long long uy)
 {
     const long long x = (long long)ux;
     const long long y = (long long)uy;
     return ((x%y)+y)%y;
 }
 inline float _brian_mod(int ux, float uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(int ux, double uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(int ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long _brian_mod(long ux, int uy)
 {
     const long x = (long)ux;
     const long y = (long)uy;
     return ((x%y)+y)%y;
 }
 inline long _brian_mod(long ux, long uy)
 {
     const long x = (long)ux;
     const long y = (long)uy;
     return ((x%y)+y)%y;
 }
 inline long long _brian_mod(long ux, long long uy)
 {
     const long long x = (long long)ux;
     const long long y = (long long)uy;
     return ((x%y)+y)%y;
 }
 inline float _brian_mod(long ux, float uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(long ux, double uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long long _brian_mod(long long ux, int uy)
 {
     const long long x = (long long)ux;
     const long long y = (long long)uy;
     return ((x%y)+y)%y;
 }
 inline long long _brian_mod(long long ux, long uy)
 {
     const long long x = (long long)ux;
     const long long y = (long long)uy;
     return ((x%y)+y)%y;
 }
 inline long long _brian_mod(long long ux, long long uy)
 {
     const long long x = (long long)ux;
     const long long y = (long long)uy;
     return ((x%y)+y)%y;
 }
 inline float _brian_mod(long long ux, float uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(long long ux, double uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long long ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline float _brian_mod(float ux, int uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline float _brian_mod(float ux, long uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline float _brian_mod(float ux, long long uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline float _brian_mod(float ux, float uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(float ux, double uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(float ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(double ux, int uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(double ux, long uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(double ux, long long uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(double ux, float uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(double ux, double uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(double ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, int uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, long uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, long long uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, float uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 #ifdef _MSC_VER
 #define _brian_pow(x, y) (pow((double)(x), (y)))
 #else
 #define _brian_pow(x, y) (pow((x), (y)))
 #endif

}

////// HASH DEFINES ///////



void _run_synapses_synapses_create_array_codeobject()
{
	using namespace brian;

    const std::clock_t _start_time = std::clock();

	///// CONSTANTS ///////////
	int32_t* const _array_synapses__synaptic_post = _dynamic_array_synapses__synaptic_post.empty()? 0 : &_dynamic_array_synapses__synaptic_post[0];
const int _num_synaptic_post = _dynamic_array_synapses__synaptic_post.size();
const int _numtargets = 1;
int32_t* const _array_synapses__synaptic_pre = _dynamic_array_synapses__synaptic_pre.empty()? 0 : &_dynamic_array_synapses__synaptic_pre[0];
const int _num_presynaptic_idx = _dynamic_array_synapses__synaptic_pre.size();
const int _num_postsynaptic_idx = _dynamic_array_synapses__synaptic_post.size();
const int _num_synaptic_pre = _dynamic_array_synapses__synaptic_pre.size();
int32_t* const _array_synapses_N_outgoing = _dynamic_array_synapses_N_outgoing.empty()? 0 : &_dynamic_array_synapses_N_outgoing[0];
const int _numN_outgoing = _dynamic_array_synapses_N_outgoing.size();
int32_t* const _array_synapses_N_incoming = _dynamic_array_synapses_N_incoming.empty()? 0 : &_dynamic_array_synapses_N_incoming[0];
const int _numN_incoming = _dynamic_array_synapses_N_incoming.size();
const int _numsources = 1;
const int _numN = 1;
	///// POINTERS ////////////
 	
 int32_t* __restrict  _ptr_array_synapses__synaptic_post = _array_synapses__synaptic_post;
 int32_t* __restrict  _ptr_array_synapses_targets = _array_synapses_targets;
 int32_t* __restrict  _ptr_array_synapses__synaptic_pre = _array_synapses__synaptic_pre;
 int32_t* __restrict  _ptr_array_synapses_N_outgoing = _array_synapses_N_outgoing;
 int32_t* __restrict  _ptr_array_synapses_N_incoming = _array_synapses_N_incoming;
 int32_t* __restrict  _ptr_array_synapses_sources = _array_synapses_sources;
 int32_t*   _ptr_array_synapses_N = _array_synapses_N;



const int _old_num_synapses = _ptr_array_synapses_N[0];
const int _new_num_synapses = _old_num_synapses + _numsources;

const int _N_pre = 2;
const int _N_post = 2;
_dynamic_array_synapses_N_incoming.resize(_N_post + 0);
_dynamic_array_synapses_N_outgoing.resize(_N_pre + 0);

for (int _idx=0; _idx<_numsources; _idx++) {
        
    const int32_t targets = _ptr_array_synapses_targets[_idx];
    const int32_t sources = _ptr_array_synapses_sources[_idx];
    const int32_t _real_sources = sources;
    const int32_t _real_targets = targets;


    _dynamic_array_synapses__synaptic_pre.push_back(_real_sources);
    _dynamic_array_synapses__synaptic_post.push_back(_real_targets);
    // Update the number of total outgoing/incoming synapses per source/target neuron
    _dynamic_array_synapses_N_outgoing[_real_sources]++;
    _dynamic_array_synapses_N_incoming[_real_targets]++;
}

// now we need to resize all registered variables
const int newsize = _dynamic_array_synapses__synaptic_pre.size();
_dynamic_array_synapses__synaptic_post.resize(newsize);
_dynamic_array_synapses__synaptic_pre.resize(newsize);
_dynamic_array_synapses_delay.resize(newsize);
_dynamic_array_synapses_lastupdate.resize(newsize);
// Also update the total number of synapses
_ptr_array_synapses_N[0] = newsize;


    const double _run_time = (double)(std::clock() -_start_time)/CLOCKS_PER_SEC;
    synapses_synapses_create_array_codeobject_profiling_info += _run_time;
}


 [brian2.devices.cpp_standalone.device]
DIAGNOSTIC Writing file code_objects/synapses_synapses_create_array_codeobject.h:
#ifndef _INCLUDED_synapses_synapses_create_array_codeobject
#define _INCLUDED_synapses_synapses_create_array_codeobject

#include "objects.h"

void _run_synapses_synapses_create_array_codeobject();


#endif
 [brian2.devices.cpp_standalone.device]
DIAGNOSTIC Writing file code_objects/neurongroup_thresholder_codeobject.cpp:
#include "objects.h"
#include "code_objects/neurongroup_thresholder_codeobject.h"
#include "brianlib/common_math.h"
#include "brianlib/stdint_compat.h"
#include<cmath>
#include<ctime>
#include<iostream>
#include<fstream>

////// SUPPORT CODE ///////
namespace {
 	
 inline int _brian_mod(int ux, int uy)
 {
     const int x = (int)ux;
     const int y = (int)uy;
     return ((x%y)+y)%y;
 }
 inline long _brian_mod(int ux, long uy)
 {
     const long x = (long)ux;
     const long y = (long)uy;
     return ((x%y)+y)%y;
 }
 inline long long _brian_mod(int ux, long long uy)
 {
     const long long x = (long long)ux;
     const long long y = (long long)uy;
     return ((x%y)+y)%y;
 }
 inline float _brian_mod(int ux, float uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(int ux, double uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(int ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long _brian_mod(long ux, int uy)
 {
     const long x = (long)ux;
     const long y = (long)uy;
     return ((x%y)+y)%y;
 }
 inline long _brian_mod(long ux, long uy)
 {
     const long x = (long)ux;
     const long y = (long)uy;
     return ((x%y)+y)%y;
 }
 inline long long _brian_mod(long ux, long long uy)
 {
     const long long x = (long long)ux;
     const long long y = (long long)uy;
     return ((x%y)+y)%y;
 }
 inline float _brian_mod(long ux, float uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(long ux, double uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long long _brian_mod(long long ux, int uy)
 {
     const long long x = (long long)ux;
     const long long y = (long long)uy;
     return ((x%y)+y)%y;
 }
 inline long long _brian_mod(long long ux, long uy)
 {
     const long long x = (long long)ux;
     const long long y = (long long)uy;
     return ((x%y)+y)%y;
 }
 inline long long _brian_mod(long long ux, long long uy)
 {
     const long long x = (long long)ux;
     const long long y = (long long)uy;
     return ((x%y)+y)%y;
 }
 inline float _brian_mod(long long ux, float uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(long long ux, double uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long long ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline float _brian_mod(float ux, int uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline float _brian_mod(float ux, long uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline float _brian_mod(float ux, long long uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline float _brian_mod(float ux, float uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(float ux, double uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(float ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(double ux, int uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(double ux, long uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(double ux, long long uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(double ux, float uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(double ux, double uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(double ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, int uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, long uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, long long uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, float uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 #ifdef _MSC_VER
 #define _brian_pow(x, y) (pow((double)(x), (y)))
 #else
 #define _brian_pow(x, y) (pow((x), (y)))
 #endif

}

////// HASH DEFINES ///////



void _run_neurongroup_thresholder_codeobject()
{
	using namespace brian;

    const std::clock_t _start_time = std::clock();

	///// CONSTANTS ///////////
	const int _numv = 2;
const int _num_spikespace = 3;
	///// POINTERS ////////////
 	
 double* __restrict  _ptr_array_neurongroup_v = _array_neurongroup_v;
 int32_t* __restrict  _ptr_array_neurongroup__spikespace = _array_neurongroup__spikespace;



	//// MAIN CODE ////////////
	// scalar code
	const int _vectorisation_idx = -1;
 	



    long _count = 0;
    for(int _idx=0; _idx<2; _idx++)
    {
        const int _vectorisation_idx = _idx;
                
        const double v = _ptr_array_neurongroup_v[_idx];
        const char _cond = v > 1;

        if(_cond) {
            _ptr_array_neurongroup__spikespace[_count++] = _idx;
        }
    }
    _ptr_array_neurongroup__spikespace[2] = _count;

    const double _run_time = (double)(std::clock() -_start_time)/CLOCKS_PER_SEC;
    neurongroup_thresholder_codeobject_profiling_info += _run_time;
}


 [brian2.devices.cpp_standalone.device]
DIAGNOSTIC Writing file code_objects/neurongroup_thresholder_codeobject.h:
#ifndef _INCLUDED_neurongroup_thresholder_codeobject
#define _INCLUDED_neurongroup_thresholder_codeobject

#include "objects.h"

void _run_neurongroup_thresholder_codeobject();


#endif
 [brian2.devices.cpp_standalone.device]
DIAGNOSTIC Writing file code_objects/synapses_pre_codeobject.cpp:
#include "objects.h"
#include "code_objects/synapses_pre_codeobject.h"
#include "brianlib/common_math.h"
#include "brianlib/stdint_compat.h"
#include<cmath>
#include<ctime>
#include<iostream>
#include<fstream>
#include "brianlib/stdint_compat.h"
#include "synapses_classes.h"

////// SUPPORT CODE ///////
namespace {
 	
 inline int _brian_mod(int ux, int uy)
 {
     const int x = (int)ux;
     const int y = (int)uy;
     return ((x%y)+y)%y;
 }
 inline long _brian_mod(int ux, long uy)
 {
     const long x = (long)ux;
     const long y = (long)uy;
     return ((x%y)+y)%y;
 }
 inline long long _brian_mod(int ux, long long uy)
 {
     const long long x = (long long)ux;
     const long long y = (long long)uy;
     return ((x%y)+y)%y;
 }
 inline float _brian_mod(int ux, float uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(int ux, double uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(int ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long _brian_mod(long ux, int uy)
 {
     const long x = (long)ux;
     const long y = (long)uy;
     return ((x%y)+y)%y;
 }
 inline long _brian_mod(long ux, long uy)
 {
     const long x = (long)ux;
     const long y = (long)uy;
     return ((x%y)+y)%y;
 }
 inline long long _brian_mod(long ux, long long uy)
 {
     const long long x = (long long)ux;
     const long long y = (long long)uy;
     return ((x%y)+y)%y;
 }
 inline float _brian_mod(long ux, float uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(long ux, double uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long long _brian_mod(long long ux, int uy)
 {
     const long long x = (long long)ux;
     const long long y = (long long)uy;
     return ((x%y)+y)%y;
 }
 inline long long _brian_mod(long long ux, long uy)
 {
     const long long x = (long long)ux;
     const long long y = (long long)uy;
     return ((x%y)+y)%y;
 }
 inline long long _brian_mod(long long ux, long long uy)
 {
     const long long x = (long long)ux;
     const long long y = (long long)uy;
     return ((x%y)+y)%y;
 }
 inline float _brian_mod(long long ux, float uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(long long ux, double uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long long ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline float _brian_mod(float ux, int uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline float _brian_mod(float ux, long uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline float _brian_mod(float ux, long long uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline float _brian_mod(float ux, float uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(float ux, double uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(float ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(double ux, int uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(double ux, long uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(double ux, long long uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(double ux, float uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(double ux, double uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(double ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, int uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, long uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, long long uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, float uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 #ifdef _MSC_VER
 #define _brian_pow(x, y) (pow((double)(x), (y)))
 #else
 #define _brian_pow(x, y) (pow((x), (y)))
 #endif

}

////// HASH DEFINES ///////



void _run_synapses_pre_codeobject()
{
	using namespace brian;

    const std::clock_t _start_time = std::clock();

	///// CONSTANTS ///////////
	double* const _array_synapses_lastupdate = _dynamic_array_synapses_lastupdate.empty()? 0 : &_dynamic_array_synapses_lastupdate[0];
const int _numlastupdate = _dynamic_array_synapses_lastupdate.size();
int32_t* const _array_synapses__synaptic_pre = _dynamic_array_synapses__synaptic_pre.empty()? 0 : &_dynamic_array_synapses__synaptic_pre[0];
const int _num_synaptic_pre = _dynamic_array_synapses__synaptic_pre.size();
int32_t* const _array_synapses__synaptic_post = _dynamic_array_synapses__synaptic_post.empty()? 0 : &_dynamic_array_synapses__synaptic_post[0];
const int _num_postsynaptic_idx = _dynamic_array_synapses__synaptic_post.size();
const int _numt = 1;
const int _numv_post = 2;
	///// POINTERS ////////////
 	
 double* __restrict  _ptr_array_synapses_lastupdate = _array_synapses_lastupdate;
 int32_t* __restrict  _ptr_array_synapses__synaptic_pre = _array_synapses__synaptic_pre;
 int32_t* __restrict  _ptr_array_synapses__synaptic_post = _array_synapses__synaptic_post;
 double*   _ptr_array_defaultclock_t = _array_defaultclock_t;
 double* __restrict  _ptr_array_neurongroup_v = _array_neurongroup_v;



	// This is only needed for the _debugmsg function below	
	

	// scalar code
	const int _vectorisation_idx = -1;
 	


	
	{
	std::vector<int> *_spiking_synapses = synapses_pre.peek();
	const unsigned int _num_spiking_synapses = _spiking_synapses->size();

	
	{
		for(unsigned int _spiking_synapse_idx=0;
			_spiking_synapse_idx<_num_spiking_synapses;
			_spiking_synapse_idx++)
		{
			const int _idx = (*_spiking_synapses)[_spiking_synapse_idx];
			const int _vectorisation_idx = _idx;
   			
   const int32_t _postsynaptic_idx = _ptr_array_synapses__synaptic_post[_idx];
   const double t = _ptr_array_defaultclock_t[0];
   double v_post = _ptr_array_neurongroup_v[_postsynaptic_idx];
   double lastupdate;
   v_post += 0.2;
   lastupdate = t;
   _ptr_array_synapses_lastupdate[_idx] = lastupdate;
   _ptr_array_neurongroup_v[_postsynaptic_idx] = v_post;

		}
	}
    }

    const double _run_time = (double)(std::clock() -_start_time)/CLOCKS_PER_SEC;
    synapses_pre_codeobject_profiling_info += _run_time;
}

void _debugmsg_synapses_pre_codeobject()
{
	using namespace brian;
	std::cout << "Number of synapses: " << _dynamic_array_synapses__synaptic_pre.size() << endl;
}

 [brian2.devices.cpp_standalone.device]
DIAGNOSTIC Writing file code_objects/synapses_pre_codeobject.h:
#ifndef _INCLUDED_synapses_pre_codeobject
#define _INCLUDED_synapses_pre_codeobject

#include "objects.h"

void _run_synapses_pre_codeobject();

void _debugmsg_synapses_pre_codeobject();

#endif
 [brian2.devices.cpp_standalone.device]
DIAGNOSTIC Writing file code_objects/neurongroup_stateupdater_codeobject.cpp:
#include "objects.h"
#include "code_objects/neurongroup_stateupdater_codeobject.h"
#include "brianlib/common_math.h"
#include "brianlib/stdint_compat.h"
#include<cmath>
#include<ctime>
#include<iostream>
#include<fstream>

////// SUPPORT CODE ///////
namespace {
 	
 inline int _brian_mod(int ux, int uy)
 {
     const int x = (int)ux;
     const int y = (int)uy;
     return ((x%y)+y)%y;
 }
 inline long _brian_mod(int ux, long uy)
 {
     const long x = (long)ux;
     const long y = (long)uy;
     return ((x%y)+y)%y;
 }
 inline long long _brian_mod(int ux, long long uy)
 {
     const long long x = (long long)ux;
     const long long y = (long long)uy;
     return ((x%y)+y)%y;
 }
 inline float _brian_mod(int ux, float uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(int ux, double uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(int ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long _brian_mod(long ux, int uy)
 {
     const long x = (long)ux;
     const long y = (long)uy;
     return ((x%y)+y)%y;
 }
 inline long _brian_mod(long ux, long uy)
 {
     const long x = (long)ux;
     const long y = (long)uy;
     return ((x%y)+y)%y;
 }
 inline long long _brian_mod(long ux, long long uy)
 {
     const long long x = (long long)ux;
     const long long y = (long long)uy;
     return ((x%y)+y)%y;
 }
 inline float _brian_mod(long ux, float uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(long ux, double uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long long _brian_mod(long long ux, int uy)
 {
     const long long x = (long long)ux;
     const long long y = (long long)uy;
     return ((x%y)+y)%y;
 }
 inline long long _brian_mod(long long ux, long uy)
 {
     const long long x = (long long)ux;
     const long long y = (long long)uy;
     return ((x%y)+y)%y;
 }
 inline long long _brian_mod(long long ux, long long uy)
 {
     const long long x = (long long)ux;
     const long long y = (long long)uy;
     return ((x%y)+y)%y;
 }
 inline float _brian_mod(long long ux, float uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(long long ux, double uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long long ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline float _brian_mod(float ux, int uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline float _brian_mod(float ux, long uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline float _brian_mod(float ux, long long uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline float _brian_mod(float ux, float uy)
 {
     const float x = (float)ux;
     const float y = (float)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(float ux, double uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(float ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(double ux, int uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(double ux, long uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(double ux, long long uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(double ux, float uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline double _brian_mod(double ux, double uy)
 {
     const double x = (double)ux;
     const double y = (double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(double ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, int uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, long uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, long long uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, float uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 inline long double _brian_mod(long double ux, long double uy)
 {
     const long double x = (long double)ux;
     const long double y = (long double)uy;
     return fmod(fmod(x, y)+y, y);
 }
 #ifdef _MSC_VER
 #define _brian_pow(x, y) (pow((double)(x), (y)))
 #else
 #define _brian_pow(x, y) (pow((x), (y)))
 #endif

}

////// HASH DEFINES ///////



void _run_neurongroup_stateupdater_codeobject()
{
	using namespace brian;

    const std::clock_t _start_time = std::clock();

	///// CONSTANTS ///////////
	const int _numI = 2;
const int _numdt = 1;
const int _numv = 2;
const int _numtau = 2;
	///// POINTERS ////////////
 	
 double* __restrict  _ptr_array_neurongroup_I = _array_neurongroup_I;
 double*   _ptr_array_defaultclock_dt = _array_defaultclock_dt;
 double* __restrict  _ptr_array_neurongroup_v = _array_neurongroup_v;
 double* __restrict  _ptr_array_neurongroup_tau = _array_neurongroup_tau;


	//// MAIN CODE ////////////
	// scalar code
	const int _vectorisation_idx = -1;
 	
 const double dt = _ptr_array_defaultclock_dt[0];
 const double _lio_1 = - dt;


	const int _N = 2;
	
	for(int _idx=0; _idx<_N; _idx++)
	{
	    // vector code
		const int _vectorisation_idx = _idx;
                
        const double I = _ptr_array_neurongroup_I[_idx];
        double v = _ptr_array_neurongroup_v[_idx];
        const double tau = _ptr_array_neurongroup_tau[_idx];
        const double _v = (I + (v * exp(_lio_1 / tau))) - (I * exp(_lio_1 / tau));
        v = _v;
        _ptr_array_neurongroup_v[_idx] = v;

	}

    const double _run_time = (double)(std::clock() -_start_time)/CLOCKS_PER_SEC;
    neurongroup_stateupdater_codeobject_profiling_info += _run_time;
}


 [brian2.devices.cpp_standalone.device]
DIAGNOSTIC Writing file code_objects/neurongroup_stateupdater_codeobject.h:
#ifndef _INCLUDED_neurongroup_stateupdater_codeobject
#define _INCLUDED_neurongroup_stateupdater_codeobject

#include "objects.h"

void _run_neurongroup_stateupdater_codeobject();


#endif
 [brian2.devices.cpp_standalone.device]
DIAGNOSTIC Writing file network.*:
h_file:
    #ifndef _BRIAN_NETWORK_H
    #define _BRIAN_NETWORK_H
    #include<vector>
    #include<utility>
    #include<set>
    #include "brianlib/clocks.h"
    typedef void (*codeobj_func)();
    class Network
    {
        std::set<Clock*> clocks, curclocks;
        void compute_clocks();
        Clock* next_clocks();
    public:
        std::vector< std::pair< Clock*, codeobj_func > > objects;
        double t;
        static double _last_run_time;
        static double _last_run_completed_fraction;
        Network();
        void clear();
        void add(Clock *clock, codeobj_func func);
        void run(const double duration, void (*report_func)(const double, const double, const double, const double), const double report_period);
    };
    #endif
cpp_file:
    #include "network.h"
    #include<stdlib.h>
    #include<iostream>
    #include <ctime>
    #include<utility>
    #define Clock_epsilon 1e-14
    double Network::_last_run_time = 0.0;
    double Network::_last_run_completed_fraction = 0.0;
    Network::Network()
    {
        t = 0.0;
    }
    void Network::clear()
    {
        objects.clear();
    }
    void Network::add(Clock* clock, codeobj_func func)
    {
    #if defined(_MSC_VER) && (_MSC_VER>=1700)
        objects.push_back(std::make_pair(std::move(clock), std::move(func)));
    #else
        objects.push_back(std::make_pair(clock, func));
    #endif
    }
    void Network::run(const double duration, void (*report_func)(const double, const double, const double, const double), const double report_period)
    {
        std::clock_t start, current;
        const double t_start = t;
        const double t_end = t + duration;
        double next_report_time = report_period;
        // compute the set of clocks
        compute_clocks();
        // set interval for all clocks
        for(std::set<Clock*>::iterator i=clocks.begin(); i!=clocks.end(); i++)
            (*i)->set_interval(t, t_end);
        start = std::clock();
        if (report_func)
        {
            report_func(0.0, 0.0, t_start, duration);
        }
        Clock* clock = next_clocks();
        double elapsed_realtime;
        bool did_break_early = false;
        while(clock && clock->running())
        {
            t = clock->t[0];
            for(int i=0; i<objects.size(); i++)
            {
                if (report_func)
                {
                    current = std::clock();
                    const double elapsed = ((double)(current - start) / CLOCKS_PER_SEC);
                    if (elapsed > next_report_time)
                    {
                        report_func(elapsed, (clock->t[0]-t_start)/duration, t_start, duration);
                        next_report_time += report_period;
                    }
                }
                Clock *obj_clock = objects[i].first;
                // Only execute the object if it uses the right clock for this step
                if (curclocks.find(obj_clock) != curclocks.end())
                {
                    codeobj_func func = objects[i].second;
                    if (func)  // code objects can be NULL in cases where we store just the clock
                        func();
                }
            }
            for(std::set<Clock*>::iterator i=curclocks.begin(); i!=curclocks.end(); i++)
                (*i)->tick();
            clock = next_clocks();
            current = std::clock();
            elapsed_realtime = (double)(current - start)/(1 * CLOCKS_PER_SEC);
        }
        if(!did_break_early) t = t_end;
        _last_run_time = elapsed_realtime;
        if(duration>0)
        {
            _last_run_completed_fraction = (t-t_start)/duration;
        } else {
            _last_run_completed_fraction = 1.0;
        }
        if (report_func)
        {
            report_func(elapsed_realtime, 1.0, t_start, duration);
        }
    }
    void Network::compute_clocks()
    {
        clocks.clear();
        for(int i=0; i<objects.size(); i++)
        {
            Clock *clock = objects[i].first;
            clocks.insert(clock);
        }
    }
    Clock* Network::next_clocks()
    {
        // find minclock, clock with smallest t value
        Clock *minclock = *clocks.begin();
        if (!minclock) // empty list of clocks
            return NULL;
        for(std::set<Clock*>::iterator i=clocks.begin(); i!=clocks.end(); i++)
        {
            Clock *clock = *i;
            if(clock->t[0]<minclock->t[0])
                minclock = clock;
        }
        // find set of equal clocks
        curclocks.clear();
        double t = minclock->t[0];
        for(std::set<Clock*>::iterator i=clocks.begin(); i!=clocks.end(); i++)
        {
            Clock *clock = *i;
            double s = clock->t[0];
            if(s==t || fabs(s-t)<=Clock_epsilon)
                curclocks.insert(clock);
        }
        return minclock;
    }
 [brian2.devices.cpp_standalone.device]
DIAGNOSTIC Writing file network.cpp:

#include "network.h"
#include<stdlib.h>
#include<iostream>
#include <ctime>
#include<utility>


#define Clock_epsilon 1e-14

double Network::_last_run_time = 0.0;
double Network::_last_run_completed_fraction = 0.0;

Network::Network()
{
    t = 0.0;
}

void Network::clear()
{
    objects.clear();
}

void Network::add(Clock* clock, codeobj_func func)
{
#if defined(_MSC_VER) && (_MSC_VER>=1700)
    objects.push_back(std::make_pair(std::move(clock), std::move(func)));
#else
    objects.push_back(std::make_pair(clock, func));
#endif
}

void Network::run(const double duration, void (*report_func)(const double, const double, const double, const double), const double report_period)
{
    std::clock_t start, current;
    const double t_start = t;
    const double t_end = t + duration;
    double next_report_time = report_period;
    // compute the set of clocks
    compute_clocks();
    // set interval for all clocks

    for(std::set<Clock*>::iterator i=clocks.begin(); i!=clocks.end(); i++)
        (*i)->set_interval(t, t_end);

    start = std::clock();
    if (report_func)
    {
        report_func(0.0, 0.0, t_start, duration);
    }

    Clock* clock = next_clocks();
    double elapsed_realtime;
    bool did_break_early = false;

    while(clock && clock->running())
    {
        t = clock->t[0];

        for(int i=0; i<objects.size(); i++)
        {
            if (report_func)
            {
                current = std::clock();
                const double elapsed = ((double)(current - start) / CLOCKS_PER_SEC);
                if (elapsed > next_report_time)
                {
                    report_func(elapsed, (clock->t[0]-t_start)/duration, t_start, duration);
                    next_report_time += report_period;
                }
            }
            Clock *obj_clock = objects[i].first;
            // Only execute the object if it uses the right clock for this step
            if (curclocks.find(obj_clock) != curclocks.end())
            {
                codeobj_func func = objects[i].second;
                if (func)  // code objects can be NULL in cases where we store just the clock
                    func();
            }
        }
        for(std::set<Clock*>::iterator i=curclocks.begin(); i!=curclocks.end(); i++)
            (*i)->tick();
        clock = next_clocks();

        current = std::clock();
        elapsed_realtime = (double)(current - start)/(1 * CLOCKS_PER_SEC);


    }

    if(!did_break_early) t = t_end;

    _last_run_time = elapsed_realtime;
    if(duration>0)
    {
        _last_run_completed_fraction = (t-t_start)/duration;
    } else {
        _last_run_completed_fraction = 1.0;
    }
    if (report_func)
    {
        report_func(elapsed_realtime, 1.0, t_start, duration);
    }
}

void Network::compute_clocks()
{
    clocks.clear();
    for(int i=0; i<objects.size(); i++)
    {
        Clock *clock = objects[i].first;
        clocks.insert(clock);
    }
}

Clock* Network::next_clocks()
{
    // find minclock, clock with smallest t value
    Clock *minclock = *clocks.begin();
    if (!minclock) // empty list of clocks
        return NULL;

    for(std::set<Clock*>::iterator i=clocks.begin(); i!=clocks.end(); i++)
    {
        Clock *clock = *i;
        if(clock->t[0]<minclock->t[0])
            minclock = clock;
    }
    // find set of equal clocks
    curclocks.clear();

    double t = minclock->t[0];
    for(std::set<Clock*>::iterator i=clocks.begin(); i!=clocks.end(); i++)
    {
        Clock *clock = *i;
        double s = clock->t[0];
        if(s==t || fabs(s-t)<=Clock_epsilon)
            curclocks.insert(clock);
    }
    return minclock;
}

 [brian2.devices.cpp_standalone.device]
DIAGNOSTIC Writing file network.h:

#ifndef _BRIAN_NETWORK_H
#define _BRIAN_NETWORK_H

#include<vector>
#include<utility>
#include<set>
#include "brianlib/clocks.h"

typedef void (*codeobj_func)();

class Network
{
    std::set<Clock*> clocks, curclocks;
    void compute_clocks();
    Clock* next_clocks();
public:
    std::vector< std::pair< Clock*, codeobj_func > > objects;
    double t;
    static double _last_run_time;
    static double _last_run_completed_fraction;

    Network();
    void clear();
    void add(Clock *clock, codeobj_func func);
    void run(const double duration, void (*report_func)(const double, const double, const double, const double), const double report_period);
};

#endif

 [brian2.devices.cpp_standalone.device]
DIAGNOSTIC Writing file synapses_classes.*:
h_file:
    #ifndef _BRIAN_SYNAPSES_H
    #define _BRIAN_SYNAPSES_H
    #include<vector>
    #include<algorithm>
    #include "brianlib/spikequeue.h"
    template<class scalar> class SynapticPathway;
    template <class scalar>
    class SynapticPathway
    {
    public:
    	int Nsource, Ntarget, _nb_threads;
    	std::vector<scalar> &delay;
    	std::vector<int> &sources;
    	std::vector<int> all_peek;
    	std::vector< CSpikeQueue<scalar> * > queue;
    	SynapticPathway(std::vector<scalar>& _delay, std::vector<int> &_sources,
    					int _spikes_start, int _spikes_stop)
    		: delay(_delay), sources(_sources)
    	{
    	   _nb_threads = 1;
    	   for (int _idx=0; _idx < _nb_threads; _idx++)
    	       queue.push_back(new CSpikeQueue<scalar>(_spikes_start, _spikes_stop));
        };
    	~SynapticPathway()
    	{
    		for (int _idx=0; _idx < _nb_threads; _idx++)
    			delete(queue[_idx]);
    	}
    	void push(int *spikes, int nspikes)
        {
        	queue[0]->push(spikes, nspikes);
        }
    	void advance()
        {
        	queue[0]->advance();
        }
    	vector<int32_t>* peek()
        {
    		for(int _thread=0; _thread < 1; _thread++)
    		{
    			{
        			if (_thread == 0)
    					all_peek.clear();
    				all_peek.insert(all_peek.end(), queue[_thread]->peek()->begin(), queue[_thread]->peek()->end());
        		}
        	}
        	return &all_peek;
        }
        void prepare(int n_source, int n_target, scalar *real_delays, int n_delays,
                     int *sources, int n_synapses, double _dt)
        {
            Nsource = n_source;
            Ntarget = n_target;
        	{
                int length;
                if (0 == _nb_threads - 1) 
                    length = n_synapses - (int)0*(n_synapses/_nb_threads);
                else
                    length = (int) n_synapses/_nb_threads;
                int padding  = 0*(n_synapses/_nb_threads);
                queue[0]->openmp_padding = padding;
                if (n_delays > 1)
        		    queue[0]->prepare(&real_delays[padding], length, &sources[padding], length, _dt);
        		else if (n_delays == 1)
        		    queue[0]->prepare(&real_delays[0], 1, &sources[padding], length, _dt);
        		else  // no synapses
        		    queue[0]->prepare(NULL, 0, &sources[padding], length, _dt);
        	}
        }
    };
    #endif
cpp_file:

 [brian2.devices.cpp_standalone.device]
DIAGNOSTIC Writing file synapses_classes.cpp:
 [brian2.devices.cpp_standalone.device]
DIAGNOSTIC Writing file synapses_classes.h:

#ifndef _BRIAN_SYNAPSES_H
#define _BRIAN_SYNAPSES_H

#include<vector>
#include<algorithm>


#include "brianlib/spikequeue.h"

template<class scalar> class SynapticPathway;

template <class scalar>
class SynapticPathway
{
public:
	int Nsource, Ntarget, _nb_threads;
	std::vector<scalar> &delay;
	std::vector<int> &sources;
	std::vector<int> all_peek;
	std::vector< CSpikeQueue<scalar> * > queue;
	SynapticPathway(std::vector<scalar>& _delay, std::vector<int> &_sources,
					int _spikes_start, int _spikes_stop)
		: delay(_delay), sources(_sources)
	{
	   _nb_threads = 1;

	   for (int _idx=0; _idx < _nb_threads; _idx++)
	       queue.push_back(new CSpikeQueue<scalar>(_spikes_start, _spikes_stop));
    };

	~SynapticPathway()
	{
		for (int _idx=0; _idx < _nb_threads; _idx++)
			delete(queue[_idx]);
	}

	void push(int *spikes, int nspikes)
    {
    	queue[0]->push(spikes, nspikes);
    }

	void advance()
    {
    	queue[0]->advance();
    }

	vector<int32_t>* peek()
    {
    	
		for(int _thread=0; _thread < 1; _thread++)
		{
			
			{
    			if (_thread == 0)
					all_peek.clear();
				all_peek.insert(all_peek.end(), queue[_thread]->peek()->begin(), queue[_thread]->peek()->end());
    		}
    	}
   
    	return &all_peek;
    }

    void prepare(int n_source, int n_target, scalar *real_delays, int n_delays,
                 int *sources, int n_synapses, double _dt)
    {
        Nsource = n_source;
        Ntarget = n_target;
    	
    	{
            int length;
            if (0 == _nb_threads - 1) 
                length = n_synapses - (int)0*(n_synapses/_nb_threads);
            else
                length = (int) n_synapses/_nb_threads;

            int padding  = 0*(n_synapses/_nb_threads);

            queue[0]->openmp_padding = padding;
            if (n_delays > 1)
    		    queue[0]->prepare(&real_delays[padding], length, &sources[padding], length, _dt);
    		else if (n_delays == 1)
    		    queue[0]->prepare(&real_delays[0], 1, &sources[padding], length, _dt);
    		else  // no synapses
    		    queue[0]->prepare(NULL, 0, &sources[padding], length, _dt);
    	}
    }

};

#endif

 [brian2.devices.cpp_standalone.device]
DIAGNOSTIC Writing file run.*:
h_file:
    void brian_start();
    void brian_end();
cpp_file:
    #include<stdlib.h>
    #include "objects.h"
    #include<ctime>
    #include "randomkit.h"
    #include "code_objects/neurongroup_resetter_codeobject.h"
    #include "code_objects/neurongroup_stateupdater_codeobject.h"
    #include "code_objects/neurongroup_thresholder_codeobject.h"
    #include "code_objects/statemonitor_codeobject.h"
    #include "code_objects/synapses_pre_codeobject.h"
    #include "code_objects/synapses_pre_initialise_queue.h"
    #include "code_objects/synapses_pre_push_spikes.h"
    #include "code_objects/synapses_synapses_create_array_codeobject.h"
    void brian_start()
    {
    	_init_arrays();
    	_load_arrays();
    	// Initialize clocks (link timestep and dt to the respective arrays)
        brian::defaultclock.timestep = brian::_array_defaultclock_timestep;
        brian::defaultclock.dt = brian::_array_defaultclock_dt;
        brian::defaultclock.t = brian::_array_defaultclock_t;
        for (int i=0; i<1; i++)
    	    rk_randomseed(brian::_mersenne_twister_states[i]);  // Note that this seed can be potentially replaced in main.cpp
    }
    void brian_end()
    {
    	_write_arrays();
    	_dealloc_arrays();
    }
 [brian2.devices.cpp_standalone.device]
DIAGNOSTIC Writing file run.cpp:
#include<stdlib.h>
#include "objects.h"
#include<ctime>
#include "randomkit.h"

#include "code_objects/neurongroup_resetter_codeobject.h"
#include "code_objects/neurongroup_stateupdater_codeobject.h"
#include "code_objects/neurongroup_thresholder_codeobject.h"
#include "code_objects/statemonitor_codeobject.h"
#include "code_objects/synapses_pre_codeobject.h"
#include "code_objects/synapses_pre_initialise_queue.h"
#include "code_objects/synapses_pre_push_spikes.h"
#include "code_objects/synapses_synapses_create_array_codeobject.h"


void brian_start()
{
	_init_arrays();
	_load_arrays();
	// Initialize clocks (link timestep and dt to the respective arrays)
    brian::defaultclock.timestep = brian::_array_defaultclock_timestep;
    brian::defaultclock.dt = brian::_array_defaultclock_dt;
    brian::defaultclock.t = brian::_array_defaultclock_t;
    for (int i=0; i<1; i++)
	    rk_randomseed(brian::_mersenne_twister_states[i]);  // Note that this seed can be potentially replaced in main.cpp
}

void brian_end()
{
	_write_arrays();
	_dealloc_arrays();
}


 [brian2.devices.cpp_standalone.device]
DIAGNOSTIC Writing file run.h:

void brian_start();
void brian_end();


 [brian2.devices.cpp_standalone.device]
DIAGNOSTIC Writing file makefile:
PROGRAM = main

SRCS = objects.cpp main.cpp code_objects/neurongroup_resetter_codeobject.cpp code_objects/statemonitor_codeobject.cpp code_objects/synapses_pre_push_spikes.cpp code_objects/synapses_pre_initialise_queue.cpp code_objects/synapses_synapses_create_array_codeobject.cpp code_objects/neurongroup_thresholder_codeobject.cpp code_objects/synapses_pre_codeobject.cpp code_objects/neurongroup_stateupdater_codeobject.cpp network.cpp synapses_classes.cpp run.cpp brianlib/randomkit/randomkit.c
H_SRCS = objects.h code_objects/neurongroup_resetter_codeobject.h code_objects/statemonitor_codeobject.h code_objects/synapses_pre_push_spikes.h code_objects/synapses_pre_initialise_queue.h code_objects/synapses_synapses_create_array_codeobject.h code_objects/neurongroup_thresholder_codeobject.h code_objects/synapses_pre_codeobject.h code_objects/neurongroup_stateupdater_codeobject.h network.h synapses_classes.h run.h brianlib/clocks.h brianlib/common_math.h brianlib/dynamic_array.h
OBJS = ${SRCS:.cpp=.o}
OBJS := ${OBJS:.c=.o}
CC = @g++
OPTIMISATIONS = -Ibrianlib/randomkit -I/usr/include -w -O3 -ffast-math -fno-finite-math-only -march=native
CFLAGS = -c -Wno-write-strings $(OPTIMISATIONS) -I.  
LFLAGS =  -Lbrianlib/randomkit -L/usr/lib -Wl,--enable-new-dtags,-R/usr/lib 
DEPS = make.deps

all: $(PROGRAM)

.PHONY: all clean

$(PROGRAM): $(OBJS) $(DEPS) makefile
	$(CC) $(OBJS) -o $(PROGRAM) $(LFLAGS)

clean:
	rm $(OBJS) $(PROGRAM) $(DEPS)

make.deps: $(SRCS) $(H_SRCS)
	$(CC) $(CFLAGS) -MM $(SRCS) > make.deps
	
ifneq ($(wildcard $(DEPS)), )
include $(DEPS)
endif

%.o : %.cpp makefile
	$(CC) $(CFLAGS) $< -o $@ [brian2.devices.cpp_standalone.device]
